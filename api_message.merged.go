// Code generated by lark_sdk_gen. DO NOT EDIT.

package lark

import (
	"context"
	"io"
)

// DeleteEphemeralMessage
//
// 在群会话中删除指定用户的临时消息卡片<br>
// 临时卡片消息可以通过该接口进行显式删除，临时卡片消息删除后将不会在该设备上留下任何痕迹。
// **权限说明** ：需要启用机器人能力；需要机器人在会话群里
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uITOyYjLykjM24iM5IjN
func (r *MessageService) DeleteEphemeralMessage(ctx context.Context, request *DeleteEphemeralMessageReq, options ...MethodOptionFunc) (*DeleteEphemeralMessageResp, *Response, error) {
	if r.cli.mock.mockMessageDeleteEphemeralMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#DeleteEphemeralMessage mock enable")
		return r.cli.mock.mockMessageDeleteEphemeralMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "DeleteEphemeralMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/ephemeral/v1/delete",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(deleteEphemeralMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageDeleteEphemeralMessage(f func(ctx context.Context, request *DeleteEphemeralMessageReq, options ...MethodOptionFunc) (*DeleteEphemeralMessageResp, *Response, error)) {
	r.mockMessageDeleteEphemeralMessage = f
}

func (r *Mock) UnMockMessageDeleteEphemeralMessage() {
	r.mockMessageDeleteEphemeralMessage = nil
}

type DeleteEphemeralMessageReq struct {
	MessageID string `json:"message_id,omitempty"` // 临时消息ID
}

type deleteEphemeralMessageResp struct {
	Code int64                       `json:"code,omitempty"`
	Msg  string                      `json:"msg,omitempty"`
	Data *DeleteEphemeralMessageResp `json:"data,omitempty"`
}

type DeleteEphemeralMessageResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessage 通过 message_id 查询消息内容
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 机器人必须在群组中
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/get
func (r *MessageService) GetMessage(ctx context.Context, request *GetMessageReq, options ...MethodOptionFunc) (*GetMessageResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessage mock enable")
		return r.cli.mock.mockMessageGetMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessage",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageGetMessage(f func(ctx context.Context, request *GetMessageReq, options ...MethodOptionFunc) (*GetMessageResp, *Response, error)) {
	r.mockMessageGetMessage = f
}

func (r *Mock) UnMockMessageGetMessage() {
	r.mockMessageGetMessage = nil
}

type GetMessageReq struct {
	MessageID string `path:"message_id" json:"-"` // 待获取消息内容的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
}

type getMessageResp struct {
	Code int64           `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string          `json:"msg,omitempty"`  // 错误描述
	Data *GetMessageResp `json:"data,omitempty"`
}

type GetMessageResp struct {
	Items []*GetMessageRespItem `json:"items,omitempty"` // -
}

type GetMessageRespItem struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessageFile 获取消息中的资源文件，包括音频，视频，图片和文件，**暂不支持表情包资源下载**。当前仅支持 100M 以内的资源文件的下载。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 机器人和消息需要在同一会话中
// - 请求的 file_key 和 message_id 需要匹配
// - 暂不支持获取合并转发消息中的子消息的资源文件
// - 获取群组消息时，应用必须拥有 获取群组中所有的消息 权限
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-resource/get
func (r *MessageService) GetMessageFile(ctx context.Context, request *GetMessageFileReq, options ...MethodOptionFunc) (*GetMessageFileResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessageFile != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessageFile mock enable")
		return r.cli.mock.mockMessageGetMessageFile(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessageFile",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/resources/:file_key",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageFileResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageGetMessageFile(f func(ctx context.Context, request *GetMessageFileReq, options ...MethodOptionFunc) (*GetMessageFileResp, *Response, error)) {
	r.mockMessageGetMessageFile = f
}

func (r *Mock) UnMockMessageGetMessageFile() {
	r.mockMessageGetMessageFile = nil
}

type GetMessageFileReq struct {
	Type      string `query:"type" json:"-"`      // 资源类型，可选"image, file“； image对应消息中的 图片，富文本消息中的图片。  file对应消息中的 文件、音频、视频、（表情包除外）, 示例值："image"
	MessageID string `path:"message_id" json:"-"` // 待查询资源对应的消息ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	FileKey   string `path:"file_key" json:"-"`   // 待查询资源的key, 示例值："file_456a92d6-c6ea-4de4-ac3f-7afcf44ac78g"
}

type getMessageFileResp struct {
	IsFile bool                `json:"is_file,omitempty"`
	Code   int64               `json:"code,omitempty"`
	Msg    string              `json:"msg,omitempty"`
	Data   *GetMessageFileResp `json:"data,omitempty"`
}

func (r *getMessageFileResp) SetReader(file io.Reader) {
	if r.Data == nil {
		r.Data = &GetMessageFileResp{}
	}
	r.Data.File = file
}

type GetMessageFileResp struct {
	File io.Reader `json:"file,omitempty"`
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessageReadUserList 查询消息的已读信息。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能查询机器人自己发送，且发送时间不超过7天的消息
// - 查询消息已读信息时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/read_users
func (r *MessageService) GetMessageReadUserList(ctx context.Context, request *GetMessageReadUserListReq, options ...MethodOptionFunc) (*GetMessageReadUserListResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessageReadUserList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessageReadUserList mock enable")
		return r.cli.mock.mockMessageGetMessageReadUserList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessageReadUserList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/read_users",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageReadUserListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageGetMessageReadUserList(f func(ctx context.Context, request *GetMessageReadUserListReq, options ...MethodOptionFunc) (*GetMessageReadUserListResp, *Response, error)) {
	r.mockMessageGetMessageReadUserList = f
}

func (r *Mock) UnMockMessageGetMessageReadUserList() {
	r.mockMessageGetMessageReadUserList = nil
}

type GetMessageReadUserListReq struct {
	UserIDType IDType  `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	PageSize   *int64  `query:"page_size" json:"-"`    // 此次调用中使用的分页的大小, 示例值：20, 取值范围：`1` ～ `100`
	PageToken  *string `query:"page_token" json:"-"`   // 下一页分页的token, 示例值："GxmvlNRvP0NdQZpa7yIqf_Lv_QuBwTQ8tXkX7w-irAghVD_TvuYd1aoJ1LQph86O-XImC4X9j9FhUPhXQDvtrQ=="
	MessageID  string  `path:"message_id" json:"-"`    // 待查询的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
}

type getMessageReadUserListResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *GetMessageReadUserListResp `json:"data,omitempty"`
}

type GetMessageReadUserListResp struct {
	Items     []*GetMessageReadUserListRespItem `json:"items,omitempty"`      // -
	HasMore   bool                              `json:"has_more,omitempty"`   // 是否还有下一页
	PageToken string                            `json:"page_token,omitempty"` // 下一页分页的token
}

type GetMessageReadUserListRespItem struct {
	UserIDType IDType `json:"user_id_type,omitempty"` // 用户id类型
	UserID     string `json:"user_id,omitempty"`      // 用户id
	Timestamp  string `json:"timestamp,omitempty"`    // 阅读时间
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessageList 获取会话（包括单聊、群组）的历史消息。
//
// 接口级别权限默认只能获取单聊消息，如果需要获取群组消息，应用还必须拥有 ***获取群组中所有的消息*** 权限
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 获取消息时，机器人必须在群组中
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/list
func (r *MessageService) GetMessageList(ctx context.Context, request *GetMessageListReq, options ...MethodOptionFunc) (*GetMessageListResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessageList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessageList mock enable")
		return r.cli.mock.mockMessageGetMessageList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessageList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageGetMessageList(f func(ctx context.Context, request *GetMessageListReq, options ...MethodOptionFunc) (*GetMessageListResp, *Response, error)) {
	r.mockMessageGetMessageList = f
}

func (r *Mock) UnMockMessageGetMessageList() {
	r.mockMessageGetMessageList = nil
}

type GetMessageListReq struct {
	ContainerIDType ContainerIDType `query:"container_id_type" json:"-"` // 容器类型 ，目前可选值仅有"chat", 示例值："chat"
	ContainerID     string          `query:"container_id" json:"-"`      // 容器的id，即chat的id, 示例值："oc_234jsi43d3ssi993d43545f"
	StartTime       *string         `query:"start_time" json:"-"`        // 历史信息的起始时间, 示例值："1609296809"
	EndTime         *string         `query:"end_time" json:"-"`          // 历史信息的结束时间, 示例值："1608594809"
	PageToken       *string         `query:"page_token" json:"-"`        // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："GxmvlNRvP0NdQZpa7yIqf_Lv_QuBwTQ8tXkX7w-irAghVD_TvuYd1aoJ1LQph86O-XImC4X9j9FhUPhXQDvtrQ=="
	PageSize        *int64          `query:"page_size" json:"-"`         // 分页大小, 示例值：10, 最大值：`50`
}

type getMessageListResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *GetMessageListResp `json:"data,omitempty"`
}

type GetMessageListResp struct {
	HasMore   bool                      `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                    `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
	Items     []*GetMessageListRespItem `json:"items,omitempty"`      // message[]
}

type GetMessageListRespItem struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// ReplyRawMessage 回复指定消息，支持文本、富文本、卡片、群名片、个人名片、图片、视频、文件等多种消息类型。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 回复私聊消息，需要机器人对用户有可见性
// - 回复群组消息，需要机器人在群中
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/reply
func (r *MessageService) ReplyRawMessage(ctx context.Context, request *ReplyRawMessageReq, options ...MethodOptionFunc) (*ReplyRawMessageResp, *Response, error) {
	if r.cli.mock.mockMessageReplyRawMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#ReplyRawMessage mock enable")
		return r.cli.mock.mockMessageReplyRawMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "ReplyRawMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/reply",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(replyRawMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageReplyRawMessage(f func(ctx context.Context, request *ReplyRawMessageReq, options ...MethodOptionFunc) (*ReplyRawMessageResp, *Response, error)) {
	r.mockMessageReplyRawMessage = f
}

func (r *Mock) UnMockMessageReplyRawMessage() {
	r.mockMessageReplyRawMessage = nil
}

type ReplyRawMessageReq struct {
	MessageID string  `path:"message_id" json:"-"` // 待回复的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	Content   string  `json:"content,omitempty"`   // 消息内容 json 格式，格式说明参考: [发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json), 示例值："{\"text\":\"<at user_id=\"ou_155184d1e73cbfb8973e5a9e698e74f2\">Tom</at> test content\"}"
	MsgType   MsgType `json:"msg_type,omitempty"`  // 消息类型，包括：text、post、image、file、audio、media、sticker、interactive、share_card、share_user, 示例值："text"
}

type replyRawMessageResp struct {
	Code int64                `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string               `json:"msg,omitempty"`  // 错误描述
	Data *ReplyRawMessageResp `json:"data,omitempty"`
}

type ReplyRawMessageResp struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendRawMessage 给指定用户或者会话发送消息，支持文本、富文本、可交互的[消息卡片](https://open.feishu.cn/document/ukTMukTMukTM/uczM3QjL3MzN04yNzcDN)、群名片、个人名片、图片、视频、音频、文件、表情包。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 给用户发送消息，需要机器人对用户有可见性
// - 给群组发送消息，需要机器人在群中
// - 该接口不支持给部门成员发消息，请使用 [批量发送消息](https://open.feishu.cn/document/ukTMukTMukTM/ucDO1EjL3gTNx4yN4UTM)
// - 消息请求体最大不能超过30k
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/create
func (r *MessageService) SendRawMessage(ctx context.Context, request *SendRawMessageReq, options ...MethodOptionFunc) (*SendRawMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendRawMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendRawMessage mock enable")
		return r.cli.mock.mockMessageSendRawMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendRawMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendRawMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageSendRawMessage(f func(ctx context.Context, request *SendRawMessageReq, options ...MethodOptionFunc) (*SendRawMessageResp, *Response, error)) {
	r.mockMessageSendRawMessage = f
}

func (r *Mock) UnMockMessageSendRawMessage() {
	r.mockMessageSendRawMessage = nil
}

type SendRawMessageReq struct {
	ReceiveIDType IDType  `query:"receive_id_type" json:"-"` // 消息接收者id类型 open_id/user_id/union_id/email/chat_id, 示例值："open_id", 可选值有: `open_id`：以open_id来识别用户([什么是 Open ID？](https://open.feishu.cn/document/home/user-identity-introduction/open-id)), `user_id`：以user_id来识别用户。需要有获取用户 userID的权限 ([什么是 User ID？](https://open.feishu.cn/document/home/user-identity-introduction/user-id)), `union_id`：以union_id来识别用户([什么是 Union ID？](https://open.feishu.cn/document/home/user-identity-introduction/union-id)), `email`：以email来识别用户。是用户的真实邮箱, `chat_id`：以chat_id来识别群聊。可以调用接口 [搜索对用户或机器人可见的群列表](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat/search) 获取chat_id。群ID说明请参考：[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description)
	ReceiveID     string  `json:"receive_id,omitempty"`      // 依据receive_id_type的值，填写对应的消息接收者id, 示例值："ou_7d8a6e6df7621556ce0d21922b676706ccs"
	Content       string  `json:"content,omitempty"`         // 消息内容，json结构，不同msg_type对应不同内容。消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，具体格式说明参考：[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json), 示例值："{\"text\":\"<at user_id=\\\"ou_155184d1e73cbfb8973e5a9e698e74f2\\\">Tom</at> test content\"}"
	MsgType       MsgType `json:"msg_type,omitempty"`        // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json), 示例值："text"
}

type sendRawMessageResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *SendRawMessageResp `json:"data,omitempty"`
}

type SendRawMessageResp struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendEphemeralMessage
//
// 用于机器人在群会话中发送指定用户可见的消息卡片。<br>
// ## 使用场景
// 临时消息卡片多用于群聊中用户与机器人交互的中间态。例如在群聊中用户需要使用待办事项类bot创建一条提醒，bot 发送了可设置提醒日期和提醒内容的一张可交互的消息卡片，此卡片在没有设置为临时卡片的情况下为群内全员可见，即群内可看见该用户与 bot 交互的过程。而设置为临时卡片后，交互过程仅该用户可见，群内其他成员只会看到最终设置完成的提醒卡片。<br>临时消息卡片可降低群消息的信噪比，并间接增加 bot 通知的用户触达。
// 需要启用机器人能力；需要机器人在会话群里。
// -  仅触发临时卡片的用户自己可见。
// - 不支持转发。
// - 只能在群聊使用。
// - 仅在用户处于在线状态的飞书客户端上可见。
// - 临时消息卡片的[呈现能力](https://open.feishu.cn/document/ukTMukTMukTM/ugTNwUjL4UDM14CO1ATN)、[交互能力](https://open.feishu.cn/document/ukTMukTMukTM/uYjNwUjL2YDM14iN2ATN)与消息卡片一致。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uETOyYjLxkjM24SM5IjN
func (r *MessageService) SendEphemeralMessage(ctx context.Context, request *SendEphemeralMessageReq, options ...MethodOptionFunc) (*SendEphemeralMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendEphemeralMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendEphemeralMessage mock enable")
		return r.cli.mock.mockMessageSendEphemeralMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendEphemeralMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/ephemeral/v1/send",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendEphemeralMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageSendEphemeralMessage(f func(ctx context.Context, request *SendEphemeralMessageReq, options ...MethodOptionFunc) (*SendEphemeralMessageResp, *Response, error)) {
	r.mockMessageSendEphemeralMessage = f
}

func (r *Mock) UnMockMessageSendEphemeralMessage() {
	r.mockMessageSendEphemeralMessage = nil
}

type SendEphemeralMessageReq struct {
	ChatID  string              `json:"chat_id,omitempty"`  // 发送临时消息的群ID（可通过[获取群列表接口](https://open.feishu.cn/document/ukTMukTMukTM/uITO5QjLykTO04iM5kDN)获取）以及事件推送获取
	OpenID  string              `json:"open_id,omitempty"`  // 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id（id介绍详见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)） 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
	UserID  string              `json:"user_id,omitempty"`  // 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id（id介绍详见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)） 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
	Email   string              `json:"email,omitempty"`    // 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id（id介绍详见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)） 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
	MsgType MsgType             `json:"msg_type,omitempty"` // 消息的类型，此处固定填 "interactive"
	Card    *MessageContentCard `json:"card,omitempty"`     // 消息卡片的描述内容，具体参考[卡片结构](https://open.feishu.cn/document/ukTMukTMukTM/uEjNwUjLxYDM14SM2ATN)
}

type sendEphemeralMessageResp struct {
	Code int64                     `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 返回码描述
	Data *SendEphemeralMessageResp `json:"data,omitempty"` // -
}

type SendEphemeralMessageResp struct {
	MessageID string `json:"message_id,omitempty"` // 消息 ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendRawMessageOld
//
// 给指定用户或者会话发送文本消息，其中会话包括私聊会话和群会话。
// 需要启用机器人能力；私聊会话时机器人需要拥有对用户的可见性，群会话需要机器人在群里
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uUjNz4SN2MjL1YzM
func (r *MessageService) SendRawMessageOld(ctx context.Context, request *SendRawMessageOldReq, options ...MethodOptionFunc) (*SendRawMessageOldResp, *Response, error) {
	if r.cli.mock.mockMessageSendRawMessageOld != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendRawMessageOld mock enable")
		return r.cli.mock.mockMessageSendRawMessageOld(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendRawMessageOld",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/message/v4/send/",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendRawMessageOldResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageSendRawMessageOld(f func(ctx context.Context, request *SendRawMessageOldReq, options ...MethodOptionFunc) (*SendRawMessageOldResp, *Response, error)) {
	r.mockMessageSendRawMessageOld = f
}

func (r *Mock) UnMockMessageSendRawMessageOld() {
	r.mockMessageSendRawMessageOld = nil
}

type SendRawMessageOldReq struct {
	ChatID  string                       `json:"chat_id,omitempty"`  // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	OpenID  string                       `json:"open_id,omitempty"`  // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	UserID  string                       `json:"user_id,omitempty"`  // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	Email   string                       `json:"email,omitempty"`    // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	RootID  *string                      `json:"root_id,omitempty"`  // 如果需要回复某条消息，填对应消息的消息 ID
	MsgType MsgType                      `json:"msg_type,omitempty"` // 消息类型，此处固定填 "text"
	Content *SendRawMessageOldReqContent `json:"content,omitempty"`  // 消息内容
}

type SendRawMessageOldReqContent struct {
	Text string                 `json:"text,omitempty"` // 文本消息内容，文本消息中可以 at 个人或全体成员<br>at 全体成员：<at user_id="all">  </at> <br> at 个人：<at user_id="ou_xxxxxxx"></at>，user_id 为用户 user_id或者open_id
	Post *MessageContentPostAll `json:"post,omitempty"` // 富文本消息
}

type sendRawMessageOldResp struct {
	Code int64                  `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 返回码描述
	Data *SendRawMessageOldResp `json:"data,omitempty"` // -
}

type SendRawMessageOldResp struct {
	MessageID string `json:"message_id,omitempty"` // 消息 ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendUrgentAppMessage 对指定消息进行应用内加急。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能加急机器人自己发送的消息
// - 加急时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/urgent_app
func (r *MessageService) SendUrgentAppMessage(ctx context.Context, request *SendUrgentAppMessageReq, options ...MethodOptionFunc) (*SendUrgentAppMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendUrgentAppMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendUrgentAppMessage mock enable")
		return r.cli.mock.mockMessageSendUrgentAppMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendUrgentAppMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/urgent_app",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendUrgentAppMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageSendUrgentAppMessage(f func(ctx context.Context, request *SendUrgentAppMessageReq, options ...MethodOptionFunc) (*SendUrgentAppMessageResp, *Response, error)) {
	r.mockMessageSendUrgentAppMessage = f
}

func (r *Mock) UnMockMessageSendUrgentAppMessage() {
	r.mockMessageSendUrgentAppMessage = nil
}

type SendUrgentAppMessageReq struct {
	UserIDType IDType   `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	MessageID  string   `path:"message_id" json:"-"`    // 待加急的消息ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	UserIDList []string `json:"user_id_list,omitempty"` // 目标用户的ID, 示例值：["ou_6yf8af6bgb9100449565764t3382b168"]
}

type sendUrgentAppMessageResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *SendUrgentAppMessageResp `json:"data,omitempty"`
}

type SendUrgentAppMessageResp struct {
	InvalidUserIDList []string `json:"invalid_user_id_list,omitempty"` // 无效的用户ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendUrgentPhoneMessage 对指定消息进行应用内加急与电话加急
//
// 特别说明：
// - 通过接口产生的电话加急将消耗企业的加急额度，请慎重调用。
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能加急机器人自己发送的消息
// - 加急时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/urgent_phone
func (r *MessageService) SendUrgentPhoneMessage(ctx context.Context, request *SendUrgentPhoneMessageReq, options ...MethodOptionFunc) (*SendUrgentPhoneMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendUrgentPhoneMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendUrgentPhoneMessage mock enable")
		return r.cli.mock.mockMessageSendUrgentPhoneMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendUrgentPhoneMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/urgent_phone",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendUrgentPhoneMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageSendUrgentPhoneMessage(f func(ctx context.Context, request *SendUrgentPhoneMessageReq, options ...MethodOptionFunc) (*SendUrgentPhoneMessageResp, *Response, error)) {
	r.mockMessageSendUrgentPhoneMessage = f
}

func (r *Mock) UnMockMessageSendUrgentPhoneMessage() {
	r.mockMessageSendUrgentPhoneMessage = nil
}

type SendUrgentPhoneMessageReq struct {
	UserIDType IDType   `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	MessageID  string   `path:"message_id" json:"-"`    // 待加急的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	UserIDList []string `json:"user_id_list,omitempty"` // 目标用户的ID, 示例值：["ou_6yf8af6bgb9100449565764t3382b168"]
}

type sendUrgentPhoneMessageResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *SendUrgentPhoneMessageResp `json:"data,omitempty"`
}

type SendUrgentPhoneMessageResp struct {
	InvalidUserIDList []string `json:"invalid_user_id_list,omitempty"` // 无效的用户ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendUrgentSmsMessage 对指定消息进行应用内加急与短信加急。
//
// 特别说明：
// - 通过接口产生的短信加急将消耗企业的加急额度，请慎重调用。
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能加急机器人自己发送的消息
// - 加急时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/urgent_sms
func (r *MessageService) SendUrgentSmsMessage(ctx context.Context, request *SendUrgentSmsMessageReq, options ...MethodOptionFunc) (*SendUrgentSmsMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendUrgentSmsMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendUrgentSmsMessage mock enable")
		return r.cli.mock.mockMessageSendUrgentSmsMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendUrgentSmsMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/urgent_sms",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendUrgentSmsMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageSendUrgentSmsMessage(f func(ctx context.Context, request *SendUrgentSmsMessageReq, options ...MethodOptionFunc) (*SendUrgentSmsMessageResp, *Response, error)) {
	r.mockMessageSendUrgentSmsMessage = f
}

func (r *Mock) UnMockMessageSendUrgentSmsMessage() {
	r.mockMessageSendUrgentSmsMessage = nil
}

type SendUrgentSmsMessageReq struct {
	UserIDType IDType   `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	MessageID  string   `path:"message_id" json:"-"`    // 待加急的消息ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	UserIDList []string `json:"user_id_list,omitempty"` // 目标用户的ID, 示例值：["ou_6yf8af6bgb9100449565764t3382b168"]
}

type sendUrgentSmsMessageResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *SendUrgentSmsMessageResp `json:"data,omitempty"`
}

type SendUrgentSmsMessageResp struct {
	InvalidUserIDList []string `json:"invalid_user_id_list,omitempty"` // 无效的用户ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateMessage 更新应用已发送的消息卡片内容。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 当前仅支持更新 ***卡片消息***
// - 只支持对所有人都更新的「共享卡片」。如果你只想更新特定人的消息卡片，必须要用户在卡片操作交互后触发，开发文档参考[「独享卡片」](https://open.feishu.cn/document/ukTMukTMukTM/uYjNwUjL2YDM14iN2ATN#49904b71)
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/patch
func (r *MessageService) UpdateMessage(ctx context.Context, request *UpdateMessageReq, options ...MethodOptionFunc) (*UpdateMessageResp, *Response, error) {
	if r.cli.mock.mockMessageUpdateMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#UpdateMessage mock enable")
		return r.cli.mock.mockMessageUpdateMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "UpdateMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockMessageUpdateMessage(f func(ctx context.Context, request *UpdateMessageReq, options ...MethodOptionFunc) (*UpdateMessageResp, *Response, error)) {
	r.mockMessageUpdateMessage = f
}

func (r *Mock) UnMockMessageUpdateMessage() {
	r.mockMessageUpdateMessage = nil
}

type UpdateMessageReq struct {
	MessageID string `path:"message_id" json:"-"` // 待更新的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	Content   string `json:"content,omitempty"`   // 消息内容 json 格式，[发送消息 content 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)，参考文档中的卡片格式|, 示例值："参考链接"
}

type updateMessageResp struct {
	Code int64              `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string             `json:"msg,omitempty"`  // 错误描述
	Data *UpdateMessageResp `json:"data,omitempty"`
}

type UpdateMessageResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// BatchGetOKR 根据OKR id批量获取OKR
//
// 使用tenant_access_token需要额外申请权限<md-perm
// href="/ssl:ttdoc/ukTMukTMukTM/uQjN3QjL0YzN04CN2cDN">以应用身份访问OKR信息</md-perm>
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/okr-v1/okr/batch_get
func (r *OKRService) BatchGetOKR(ctx context.Context, request *BatchGetOKRReq, options ...MethodOptionFunc) (*BatchGetOKRResp, *Response, error) {
	if r.cli.mock.mockOKRBatchGetOKR != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] OKR#BatchGetOKR mock enable")
		return r.cli.mock.mockOKRBatchGetOKR(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "OKR",
		API:                   "BatchGetOKR",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/okr/v1/okrs/batch_get",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(batchGetOKRResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockOKRBatchGetOKR(f func(ctx context.Context, request *BatchGetOKRReq, options ...MethodOptionFunc) (*BatchGetOKRResp, *Response, error)) {
	r.mockOKRBatchGetOKR = f
}

func (r *Mock) UnMockOKRBatchGetOKR() {
	r.mockOKRBatchGetOKR = nil
}

type BatchGetOKRReq struct {
	UserIDType *IDType  `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	OKRIDs     []string `query:"okr_ids" json:"-"`      // OKR ID 列表，最多10个
	Lang       *string  `query:"lang" json:"-"`         // 请求OKR的语言版本（比如@的人名），lang=en_us/zh_cn，请求 Query中, 示例值："zh_cn", 默认值: `zh_cn`
}

type batchGetOKRResp struct {
	Code int64            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string           `json:"msg,omitempty"`  // 错误描述
	Data *BatchGetOKRResp `json:"data,omitempty"`
}

type BatchGetOKRResp struct {
	OKRList []*BatchGetOKRRespOKR `json:"okr_list,omitempty"` // OKR 列表
}

type BatchGetOKRRespOKR struct {
	ID            string                         `json:"id,omitempty"`             // id
	Permission    int64                          `json:"permission,omitempty"`     // OKR的访问权限, 可选值有: `0`：此时OKR只返回id, `1`：返回OKR的其他具体字段
	Name          string                         `json:"name,omitempty"`           // 名称
	ObjectiveList []*BatchGetOKRRespOKRObjective `json:"objective_list,omitempty"` // Objective列表
}

type BatchGetOKRRespOKRObjective struct {
	ID                    string                                          `json:"id,omitempty"`                      // Objective ID
	Permission            int64                                           `json:"permission,omitempty"`              // 权限, 可选值有: `0`：此时OKR只返回id, `1`：返回OKR的其他具体字段
	Content               string                                          `json:"content,omitempty"`                 // Objective 内容
	ProgressReport        string                                          `json:"progress_report,omitempty"`         // Objective 进度记录内容
	Score                 int64                                           `json:"score,omitempty"`                   // Objective 分数（0 - 100）
	Weight                float64                                         `json:"weight,omitempty"`                  // Objective的权重（0 - 100）
	ProgressRate          *BatchGetOKRRespOKRObjectiveProgressRate        `json:"progress_rate,omitempty"`           // Objective进度
	KrList                []*BatchGetOKRRespOKRObjectiveKr                `json:"kr_list,omitempty"`                 // Objective KeyResult 列表
	AlignedObjectiveList  []*BatchGetOKRRespOKRObjectiveAlignedObjective  `json:"aligned_objective_list,omitempty"`  // 对齐到该Objective的Objective列表
	AligningObjectiveList []*BatchGetOKRRespOKRObjectiveAligningObjective `json:"aligning_objective_list,omitempty"` // 该Objective对齐到的Objective列表
}

type BatchGetOKRRespOKRObjectiveProgressRate struct {
	Percent int64  `json:"percent,omitempty"` // Objective 进度百分比 >= 0
	Status  string `json:"status,omitempty"`  // Objective 进度状态, 可选值有: `-1`：未更新, `0`：正常, `1`：有风险, `2`：已延期
}

type BatchGetOKRRespOKRObjectiveKr struct {
	ID           string                                     `json:"id,omitempty"`            // Key Result ID
	Content      string                                     `json:"content,omitempty"`       // KeyResult 内容
	Score        int64                                      `json:"score,omitempty"`         // KeyResult打分（0 - 100）
	Weight       int64                                      `json:"weight,omitempty"`        // KeyResult权重（0 - 100）（废弃）
	KrWeight     float64                                    `json:"kr_weight,omitempty"`     // KeyResult的权重（0 - 100）
	ProgressRate *BatchGetOKRRespOKRObjectiveKrProgressRate `json:"progress_rate,omitempty"` // KR进度
}

type BatchGetOKRRespOKRObjectiveKrProgressRate struct {
	Percent int64  `json:"percent,omitempty"` // Objective 进度百分比 >= 0
	Status  string `json:"status,omitempty"`  // Objective 进度状态, 可选值有: `-1`：未更新, `0`：正常, `1`：有风险, `2`：已延期
}

type BatchGetOKRRespOKRObjectiveAlignedObjective struct {
	ID    string                                            `json:"id,omitempty"`     // Objective的ID
	OKRID string                                            `json:"okr_id,omitempty"` // OKR的ID
	Owner *BatchGetOKRRespOKRObjectiveAlignedObjectiveOwner `json:"owner,omitempty"`  // 该Objective的Owner
}

type BatchGetOKRRespOKRObjectiveAlignedObjectiveOwner struct {
	OpenID string `json:"open_id,omitempty"` // 用户的 open_id
}

type BatchGetOKRRespOKRObjectiveAligningObjective struct {
	ID    string                                             `json:"id,omitempty"`     // Objective的ID
	OKRID string                                             `json:"okr_id,omitempty"` // OKR的ID
	Owner *BatchGetOKRRespOKRObjectiveAligningObjectiveOwner `json:"owner,omitempty"`  // 该Objective的Owner
}

type BatchGetOKRRespOKRObjectiveAligningObjectiveOwner struct {
	OpenID string `json:"open_id,omitempty"` // 用户的 open_id
}
