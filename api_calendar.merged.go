// Code generated by lark_sdk_gen. DO NOT EDIT.

package lark

import (
	"context"
)

// DeleteCalendarACL
//
// 该接口用于以当前身份（应用 / 用户）删除日历的控制权限，即日历成员。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份需要有日历的 owner 权限，并且日历的类型只能为 primary 或 shared。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/delete
func (r *CalendarService) DeleteCalendarACL(ctx context.Context, request *DeleteCalendarACLReq, options ...MethodOptionFunc) (*DeleteCalendarACLResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarACL != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarACL mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarACL(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarACL",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/acls/:acl_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarACLResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarDeleteCalendarACL(f func(ctx context.Context, request *DeleteCalendarACLReq, options ...MethodOptionFunc) (*DeleteCalendarACLResp, *Response, error)) {
	r.mockCalendarDeleteCalendarACL = f
}

func (r *Mock) UnMockCalendarDeleteCalendarACL() {
	r.mockCalendarDeleteCalendarACL = nil
}

type DeleteCalendarACLReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	ACLID      string `path:"acl_id" json:"-"`      // acl资源ID, 示例值："user_xxxxxx"
}

type deleteCalendarACLResp struct {
	Code int64                  `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarACLResp `json:"data,omitempty"`
}

type DeleteCalendarACLResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarACLList
//
// 该接口用于以当前身份（应用 / 用户）获取日历的控制权限列表。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份需要有日历的 owner 权限，并且日历的类型只能为 primary 或 shared。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/list
func (r *CalendarService) GetCalendarACLList(ctx context.Context, request *GetCalendarACLListReq, options ...MethodOptionFunc) (*GetCalendarACLListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarACLList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarACLList mock enable")
		return r.cli.mock.mockCalendarGetCalendarACLList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarACLList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/acls",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarACLListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendarACLList(f func(ctx context.Context, request *GetCalendarACLListReq, options ...MethodOptionFunc) (*GetCalendarACLListResp, *Response, error)) {
	r.mockCalendarGetCalendarACLList = f
}

func (r *Mock) UnMockCalendarGetCalendarACLList() {
	r.mockCalendarGetCalendarACLList = nil
}

type GetCalendarACLListReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	PageToken  *string `query:"page_token" json:"-"`   // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："xxx"
	PageSize   *int64  `query:"page_size" json:"-"`    // 分页大小, 示例值：10，小于10取10, 最大值：`50`
	CalendarID string  `path:"calendar_id" json:"-"`   // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type getCalendarACLListResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarACLListResp `json:"data,omitempty"`
}

type GetCalendarACLListResp struct {
	Acls      []*GetCalendarACLListRespACL `json:"acls,omitempty"`       // 入参日历对应的acl列表
	HasMore   bool                         `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                       `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

type GetCalendarACLListRespACL struct {
	ACLID string                          `json:"acl_id,omitempty"` // acl资源ID
	Role  CalendarRole                    `json:"role,omitempty"`   // 对日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
	Scope *GetCalendarACLListRespACLScope `json:"scope,omitempty"`  // 权限范围
}

type GetCalendarACLListRespACLScope struct {
	Type   string `json:"type,omitempty"`    // 权限类型，当type为User时，值为open_id/user_id/union_id, 可选值有: `user`：用户
	UserID string `json:"user_id,omitempty"` // 用户ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendarACL 该接口用于以用户身份订阅指定日历下的日历成员变更事件。
//
// 用户必须对日历有访问权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/subscription
func (r *CalendarService) SubscribeCalendarACL(ctx context.Context, request *SubscribeCalendarACLReq, options ...MethodOptionFunc) (*SubscribeCalendarACLResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendarACL != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendarACL mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendarACL(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SubscribeCalendarACL",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/acls/subscription",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(subscribeCalendarACLResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarSubscribeCalendarACL(f func(ctx context.Context, request *SubscribeCalendarACLReq, options ...MethodOptionFunc) (*SubscribeCalendarACLResp, *Response, error)) {
	r.mockCalendarSubscribeCalendarACL = f
}

func (r *Mock) UnMockCalendarSubscribeCalendarACL() {
	r.mockCalendarSubscribeCalendarACL = nil
}

type SubscribeCalendarACLReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type subscribeCalendarACLResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarACLResp `json:"data,omitempty"`
}

type SubscribeCalendarACLResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendar
//
// 该接口用于为当前身份（应用 / 用户）创建一个共享日历。
// 身份由 Header Authorization 的 Token 类型决定。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/create
func (r *CalendarService) CreateCalendar(ctx context.Context, request *CreateCalendarReq, options ...MethodOptionFunc) (*CreateCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendar mock enable")
		return r.cli.mock.mockCalendarCreateCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarCreateCalendar(f func(ctx context.Context, request *CreateCalendarReq, options ...MethodOptionFunc) (*CreateCalendarResp, *Response, error)) {
	r.mockCalendarCreateCalendar = f
}

func (r *Mock) UnMockCalendarCreateCalendar() {
	r.mockCalendarCreateCalendar = nil
}

type CreateCalendarReq struct {
	Summary      *string             `json:"summary,omitempty"`       // 日历标题, 示例值："测试日历", 最大长度：`255` 字符
	Description  *string             `json:"description,omitempty"`   // 日历描述, 示例值："使用开放接口创建日历", 最大长度：`255` 字符
	Permissions  *CalendarPermission `json:"permissions,omitempty"`   // 日历公开范围, 示例值："private", 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        *int64              `json:"color,omitempty"`         // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效, 示例值：-1
	SummaryAlias *string             `json:"summary_alias,omitempty"` // 日历备注名，修改或添加后仅对当前身份生效, 示例值："日历备注名", 最大长度：`255` 字符
}

type createCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarResp `json:"data,omitempty"`
}

type CreateCalendarResp struct {
	Calendar *CreateCalendarRespCalendar `json:"calendar,omitempty"` // 新创建的日历实体
}

type CreateCalendarRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID
	Summary      string             `json:"summary,omitempty"`        // 日历标题, 最大长度：`255` 字符
	Description  string             `json:"description,omitempty"`    // 日历描述, 最大长度：`255` 字符
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效, 最大长度：`255` 字符
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除, 默认值: `false`
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入, 默认值: `false`
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendar
//
// 该接口用于以当前身份（应用 / 用户）删除一个共享日历。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历具有 owner 权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/delete
func (r *CalendarService) DeleteCalendar(ctx context.Context, request *DeleteCalendarReq, options ...MethodOptionFunc) (*DeleteCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendar mock enable")
		return r.cli.mock.mockCalendarDeleteCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendar",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarDeleteCalendar(f func(ctx context.Context, request *DeleteCalendarReq, options ...MethodOptionFunc) (*DeleteCalendarResp, *Response, error)) {
	r.mockCalendarDeleteCalendar = f
}

func (r *Mock) UnMockCalendarDeleteCalendar() {
	r.mockCalendarDeleteCalendar = nil
}

type DeleteCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type deleteCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarResp `json:"data,omitempty"`
}

type DeleteCalendarResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEventAttendeeChatMemberList 获取日程的群参与人的群成员列表。
//
// - 当前身份必须有权限查看日程的参与人列表。
// - 当前身份必须在群聊中，或有权限查看群成员列表。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee-chat_member/list
func (r *CalendarService) GetCalendarEventAttendeeChatMemberList(ctx context.Context, request *GetCalendarEventAttendeeChatMemberListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeChatMemberListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEventAttendeeChatMemberList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEventAttendeeChatMemberList mock enable")
		return r.cli.mock.mockCalendarGetCalendarEventAttendeeChatMemberList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEventAttendeeChatMemberList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees/:attendee_id/chat_members",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventAttendeeChatMemberListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendarEventAttendeeChatMemberList(f func(ctx context.Context, request *GetCalendarEventAttendeeChatMemberListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeChatMemberListResp, *Response, error)) {
	r.mockCalendarGetCalendarEventAttendeeChatMemberList = f
}

func (r *Mock) UnMockCalendarGetCalendarEventAttendeeChatMemberList() {
	r.mockCalendarGetCalendarEventAttendeeChatMemberList = nil
}

type GetCalendarEventAttendeeChatMemberListReq struct {
	PageToken  *string `query:"page_token" json:"-"` // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："23jhysaxxxxsysy"
	PageSize   *int64  `query:"page_size" json:"-"`  // 分页大小, 示例值：10, 最大值：`100`
	CalendarID string  `path:"calendar_id" json:"-"` // 日历 ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID    string  `path:"event_id" json:"-"`    // 日程 ID, 示例值："xxxxxxxxx_0"
	AttendeeID string  `path:"attendee_id" json:"-"` // 参与人 ID, 示例值："oc_xxxxxxxx"
}

type getCalendarEventAttendeeChatMemberListResp struct {
	Code int64                                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                                      `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventAttendeeChatMemberListResp `json:"data,omitempty"`
}

type GetCalendarEventAttendeeChatMemberListResp struct {
	Items     []*GetCalendarEventAttendeeChatMemberListRespItem `json:"items,omitempty"`      // 群中的群成员，当type为chat时有效；群成员不支持编辑
	HasMore   bool                                              `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                                            `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

type GetCalendarEventAttendeeChatMemberListRespItem struct {
	RsvpStatus  string `json:"rsvp_status,omitempty"`  // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional  bool   `json:"is_optional,omitempty"`  // 参与人是否为「可选参加」, 默认值: `false`
	DisplayName string `json:"display_name,omitempty"` // 参与人名称
	IsOrganizer bool   `json:"is_organizer,omitempty"` // 参与人是否为日程组织者
	IsExternal  bool   `json:"is_external,omitempty"`  // 参与人是否为外部参与人
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendarEventAttendee 批量给日程添加参与人。
//
// - 当前身份需要有日历的 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// - 当前身份需要是日程的组织者，或日程设置了「参与人可邀请其它参与人」权限。
// - 新添加的日程参与人必须与日程组织者在同一个企业内。
// - 使用该接口添加会议室后，会议室会进入异步的预约流程，请求结束不代表会议室预约成功，需后续再查询预约状态。
// - 每个日程最多只能有 3000 名参与人。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/create
func (r *CalendarService) CreateCalendarEventAttendee(ctx context.Context, request *CreateCalendarEventAttendeeReq, options ...MethodOptionFunc) (*CreateCalendarEventAttendeeResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendarEventAttendee != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendarEventAttendee mock enable")
		return r.cli.mock.mockCalendarCreateCalendarEventAttendee(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendarEventAttendee",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createCalendarEventAttendeeResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarCreateCalendarEventAttendee(f func(ctx context.Context, request *CreateCalendarEventAttendeeReq, options ...MethodOptionFunc) (*CreateCalendarEventAttendeeResp, *Response, error)) {
	r.mockCalendarCreateCalendarEventAttendee = f
}

func (r *Mock) UnMockCalendarCreateCalendarEventAttendee() {
	r.mockCalendarCreateCalendarEventAttendee = nil
}

type CreateCalendarEventAttendeeReq struct {
	UserIDType       *IDType                                   `query:"user_id_type" json:"-"`      // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	CalendarID       string                                    `path:"calendar_id" json:"-"`        // 日历 ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string                                    `path:"event_id" json:"-"`           // 日程 ID, 示例值："xxxxxxxxx_0"
	Attendees        []*CreateCalendarEventAttendeeReqAttendee `json:"attendees,omitempty"`         // 新增参与人列表
	NeedNotification *bool                                     `json:"need_notification,omitempty"` // 是否给参与人发送bot通知 默认为true, 示例值：false
}

type CreateCalendarEventAttendeeReqAttendee struct {
	Type            *CalendarEventAttendeeType `json:"type,omitempty"`              // 参与人类型；暂不支持创建邮箱参与人。, 示例值："user", 可选值有: `user`：用户, `chat`：群组, `resource`：会议室, `third_party`：邮箱
	IsOptional      *bool                      `json:"is_optional,omitempty"`       // 参与人是否为「可选参加」，无法编辑群参与人的此字段, 示例值：true, 默认值: `false`
	UserID          *string                    `json:"user_id,omitempty"`           // 参与人的用户id，依赖于user_id_type返回对应的取值，当is_external为true时，此字段只会返回open_id或者union_id, 示例值："ou_xxxxxxxx"
	ChatID          *string                    `json:"chat_id,omitempty"`           // chat类型参与人的群组chat_id, 示例值："oc_xxxxxxxxx"
	RoomID          *string                    `json:"room_id,omitempty"`           // resource类型参与人的会议室room_id, 示例值："omm_xxxxxxxx"
	ThirdPartyEmail *string                    `json:"third_party_email,omitempty"` // third_party类型参与人的邮箱, 示例值："wangwu@email.com"
	OperateID       *string                    `json:"operate_id,omitempty"`        // 如果日程是使用应用身份创建的，在添加会议室的时候，用来指定会议室的联系人，在会议室视图展示。, 示例值："ou_xxxxxxxx"
}

type createCalendarEventAttendeeResp struct {
	Code int64                            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                           `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarEventAttendeeResp `json:"data,omitempty"`
}

type CreateCalendarEventAttendeeResp struct {
	Attendees []*CreateCalendarEventAttendeeRespAttendee `json:"attendees,omitempty"` // 新增参与人后的日程所有参与人列表
}

type CreateCalendarEventAttendeeRespAttendee struct {
	Type            CalendarEventAttendeeType                            `json:"type,omitempty"`              // 参与人类型；暂不支持创建邮箱参与人。, 可选值有: `user`：用户, `chat`：群组, `resource`：会议室, `third_party`：邮箱
	AttendeeID      string                                               `json:"attendee_id,omitempty"`       // 参与人ID
	RsvpStatus      string                                               `json:"rsvp_status,omitempty"`       // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional      bool                                                 `json:"is_optional,omitempty"`       // 参与人是否为「可选参加」，无法编辑群参与人的此字段
	IsOrganizer     bool                                                 `json:"is_organizer,omitempty"`      // 参与人是否为日程组织者
	IsExternal      bool                                                 `json:"is_external,omitempty"`       // 参与人是否为外部参与人；外部参与人不支持编辑
	DisplayName     string                                               `json:"display_name,omitempty"`      // 参与人名称
	ChatMembers     []*CreateCalendarEventAttendeeRespAttendeeChatMember `json:"chat_members,omitempty"`      // 群中的群成员，当type为Chat时有效；群成员不支持编辑
	UserID          string                                               `json:"user_id,omitempty"`           // 参与人的用户id，依赖于user_id_type返回对应的取值，当is_external为true时，此字段只会返回open_id或者union_id
	ChatID          string                                               `json:"chat_id,omitempty"`           // chat类型参与人的群组chat_id
	RoomID          string                                               `json:"room_id,omitempty"`           // resource类型参与人的会议室room_id
	ThirdPartyEmail string                                               `json:"third_party_email,omitempty"` // third_party类型参与人的邮箱
	OperateID       string                                               `json:"operate_id,omitempty"`        // 如果日程是使用应用身份创建的，在添加会议室的时候，用来指定会议室的联系人，在会议室视图展示。
}

type CreateCalendarEventAttendeeRespAttendeeChatMember struct {
	RsvpStatus  string `json:"rsvp_status,omitempty"`  // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional  bool   `json:"is_optional,omitempty"`  // 参与人是否为「可选参加」
	DisplayName string `json:"display_name,omitempty"` // 参与人名称
	IsOrganizer bool   `json:"is_organizer,omitempty"` // 参与人是否为日程组织者
	IsExternal  bool   `json:"is_external,omitempty"`  // 参与人是否为外部参与人
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendarEventAttendee 批量删除日程的参与人。
//
// - 当前身份需要有日历的 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// - 当前身份需要是日程的组织者。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/batch_delete
func (r *CalendarService) DeleteCalendarEventAttendee(ctx context.Context, request *DeleteCalendarEventAttendeeReq, options ...MethodOptionFunc) (*DeleteCalendarEventAttendeeResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarEventAttendee != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarEventAttendee mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarEventAttendee(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarEventAttendee",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees/batch_delete",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarEventAttendeeResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarDeleteCalendarEventAttendee(f func(ctx context.Context, request *DeleteCalendarEventAttendeeReq, options ...MethodOptionFunc) (*DeleteCalendarEventAttendeeResp, *Response, error)) {
	r.mockCalendarDeleteCalendarEventAttendee = f
}

func (r *Mock) UnMockCalendarDeleteCalendarEventAttendee() {
	r.mockCalendarDeleteCalendarEventAttendee = nil
}

type DeleteCalendarEventAttendeeReq struct {
	CalendarID       string   `path:"calendar_id" json:"-"`        // 日历 ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string   `path:"event_id" json:"-"`           // 日程 ID, 示例值："xxxxxxxxx_0"
	AttendeeIDs      []string `json:"attendee_ids,omitempty"`      // 要移除的参与人 ID 列表
	NeedNotification *bool    `json:"need_notification,omitempty"` // 删除日程参与人时是否要给参与人发送bot通知，默认为true, 示例值：false
}

type deleteCalendarEventAttendeeResp struct {
	Code int64                            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                           `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarEventAttendeeResp `json:"data,omitempty"`
}

type DeleteCalendarEventAttendeeResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEventAttendeeList 获取日程的参与人列表，若参与者列表中有群组，请使用 [获取参与人群成员列表](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee-chat_member/list) 。
//
// - 当前身份必须对日历有访问权限。
// - 当前身份必须有权限查看日程的参与人列表。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/list
func (r *CalendarService) GetCalendarEventAttendeeList(ctx context.Context, request *GetCalendarEventAttendeeListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEventAttendeeList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEventAttendeeList mock enable")
		return r.cli.mock.mockCalendarGetCalendarEventAttendeeList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEventAttendeeList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventAttendeeListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendarEventAttendeeList(f func(ctx context.Context, request *GetCalendarEventAttendeeListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeListResp, *Response, error)) {
	r.mockCalendarGetCalendarEventAttendeeList = f
}

func (r *Mock) UnMockCalendarGetCalendarEventAttendeeList() {
	r.mockCalendarGetCalendarEventAttendeeList = nil
}

type GetCalendarEventAttendeeListReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	PageToken  *string `query:"page_token" json:"-"`   // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："780TRhwXXXXX"
	PageSize   *int64  `query:"page_size" json:"-"`    // 分页大小, 示例值：10, 最大值：`100`
	CalendarID string  `path:"calendar_id" json:"-"`   // 日历 ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID    string  `path:"event_id" json:"-"`      // 日程 ID, 示例值："xxxxxxxxx_0"
}

type getCalendarEventAttendeeListResp struct {
	Code int64                             `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                            `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventAttendeeListResp `json:"data,omitempty"`
}

type GetCalendarEventAttendeeListResp struct {
	Items     []*GetCalendarEventAttendeeListRespItem `json:"items,omitempty"`      // 日程的参与者列表
	HasMore   bool                                    `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                                  `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

type GetCalendarEventAttendeeListRespItem struct {
	Type            CalendarEventAttendeeType                         `json:"type,omitempty"`              // 参与人类型；暂不支持创建邮箱参与人。, 可选值有: `user`：用户, `chat`：群组, `resource`：会议室, `third_party`：邮箱
	AttendeeID      string                                            `json:"attendee_id,omitempty"`       // 参与人ID
	RsvpStatus      string                                            `json:"rsvp_status,omitempty"`       // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional      bool                                              `json:"is_optional,omitempty"`       // 参与人是否为「可选参加」，无法编辑群参与人的此字段
	IsOrganizer     bool                                              `json:"is_organizer,omitempty"`      // 参与人是否为日程组织者
	IsExternal      bool                                              `json:"is_external,omitempty"`       // 参与人是否为外部参与人；外部参与人不支持编辑
	DisplayName     string                                            `json:"display_name,omitempty"`      // 参与人名称
	ChatMembers     []*GetCalendarEventAttendeeListRespItemChatMember `json:"chat_members,omitempty"`      // 群中的群成员，当type为Chat时有效；群成员不支持编辑
	UserID          string                                            `json:"user_id,omitempty"`           // 参与人的用户id，依赖于user_id_type返回对应的取值，当is_external为true时，此字段只会返回open_id或者union_id
	ChatID          string                                            `json:"chat_id,omitempty"`           // chat类型参与人的群组chat_id
	RoomID          string                                            `json:"room_id,omitempty"`           // resource类型参与人的会议室room_id
	ThirdPartyEmail string                                            `json:"third_party_email,omitempty"` // third_party类型参与人的邮箱
}

type GetCalendarEventAttendeeListRespItemChatMember struct {
	RsvpStatus  string `json:"rsvp_status,omitempty"`  // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional  bool   `json:"is_optional,omitempty"`  // 参与人是否为「可选参加」
	DisplayName string `json:"display_name,omitempty"` // 参与人名称
	IsOrganizer bool   `json:"is_organizer,omitempty"` // 参与人是否为日程组织者
	IsExternal  bool   `json:"is_external,omitempty"`  // 参与人是否为外部参与人
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendarEvent
//
// 该接口用于以当前身份（应用 / 用户）在日历上创建一个日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/create
func (r *CalendarService) CreateCalendarEvent(ctx context.Context, request *CreateCalendarEventReq, options ...MethodOptionFunc) (*CreateCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendarEvent mock enable")
		return r.cli.mock.mockCalendarCreateCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendarEvent",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarCreateCalendarEvent(f func(ctx context.Context, request *CreateCalendarEventReq, options ...MethodOptionFunc) (*CreateCalendarEventResp, *Response, error)) {
	r.mockCalendarCreateCalendarEvent = f
}

func (r *Mock) UnMockCalendarCreateCalendarEvent() {
	r.mockCalendarCreateCalendarEvent = nil
}

type CreateCalendarEventReq struct {
	CalendarID       string                            `path:"calendar_id" json:"-"`        // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	Summary          *string                           `json:"summary,omitempty"`           // 日程标题, 示例值："日程标题", 最大长度：`1000` 字符
	Description      *string                           `json:"description,omitempty"`       // 日程描述, 示例值："日程描述", 最大长度：`8192` 字符
	NeedNotification *bool                             `json:"need_notification,omitempty"` // 更新日程是否给日程参与人发送bot通知，默认为true, 示例值：false
	StartTime        *CreateCalendarEventReqStartTime  `json:"start_time,omitempty"`        // 日程开始时间
	EndTime          *CreateCalendarEventReqEndTime    `json:"end_time,omitempty"`          // 日程结束时间
	Vchat            *CreateCalendarEventReqVchat      `json:"vchat,omitempty"`             // 视频会议信息。
	Visibility       *string                           `json:"visibility,omitempty"`        // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："default", 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  *string                           `json:"attendee_ability,omitempty"`  // 参与人权限, 示例值："can_see_others", 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   *string                           `json:"free_busy_status,omitempty"`  // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："busy", 可选值有: `busy`：忙碌, `free`：空闲
	Location         *CreateCalendarEventReqLocation   `json:"location,omitempty"`          // 日程地点
	Color            *int64                            `json:"color,omitempty"`             // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。, 示例值：-1
	Reminders        []*CreateCalendarEventReqReminder `json:"reminders,omitempty"`         // 日程提醒列表
	Recurrence       *string                           `json:"recurrence,omitempty"`        // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。, 示例值："FREQ=DAILY;INTERVAL=1", 最大长度：`2000` 字符
	Schemas          []*CreateCalendarEventReqSchema   `json:"schemas,omitempty"`           // 日程自定义信息
}

type CreateCalendarEventReqStartTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1605024000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

type CreateCalendarEventReqEndTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1605024000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

type CreateCalendarEventReqVchat struct {
	VCType      *string `json:"vc_type,omitempty"`     // 视频会议类型, 示例值："third_party", 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：Lark直播，内部类型，只读。, `unknown`：未知类型，做兼容使用，只读。
	IconType    *string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 示例值："vc", 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description *string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案, 示例值："发起视频会议", 长度范围：`0` ～ `500` 字符
	MeetingURL  *string `json:"meeting_url,omitempty"` // 视频会议URL, 示例值："https://example.com", 长度范围：`1` ～ `2000` 字符
}

type CreateCalendarEventReqLocation struct {
	Name      *string  `json:"name,omitempty"`      // 地点名称, 示例值："地点名称", 长度范围：`1` ～ `512` 字符
	Address   *string  `json:"address,omitempty"`   // 地点地址, 示例值："地点地址", 长度范围：`1` ～ `255` 字符
	Latitude  *float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：1.100000023841858
	Longitude *float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：2.200000047683716
}

type CreateCalendarEventReqReminder struct {
	Minutes *int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效, 示例值：5, 取值范围：`-20160` ～ `20160`
}

type CreateCalendarEventReqSchema struct {
	UiName   *string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： \,ForwardIcon: 日程转发按钮 \,MeetingChatIcon: 会议群聊按钮 \,MeetingMinutesIcon: 会议纪要按钮 \,MeetingVideo: 视频会议区域 \,RSVP: 接受/拒绝/待定区域 \,Attendee: 参与者区域 \,OrganizerOrCreator: 组织者/创建者区域, 示例值："ForwardIcon"
	UiStatus *string `json:"ui_status,omitempty"` // UI项自定义状态。目前只支持hide, 示例值："hide", 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  *string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接, 示例值："https://applink.feishu.cn/client/calendar/event/detail?calendarId=xxxxxx&key=xxxxxx&originalTime=xxxxxx&startTime=xxxxxx", 最大长度：`2000` 字符
}

type createCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarEventResp `json:"data,omitempty"`
}

type CreateCalendarEventResp struct {
	Event *CreateCalendarEventRespEvent `json:"event,omitempty"` // 新创建的日程实体
}

type CreateCalendarEventRespEvent struct {
	EventID          string                                  `json:"event_id,omitempty"`           // 日程ID
	Summary          string                                  `json:"summary,omitempty"`            // 日程标题
	Description      string                                  `json:"description,omitempty"`        // 日程描述
	NeedNotification bool                                    `json:"need_notification,omitempty"`  // 更新日程是否给日程参与人发送bot通知，默认为true
	StartTime        *CreateCalendarEventRespEventStartTime  `json:"start_time,omitempty"`         // 日程开始时间
	EndTime          *CreateCalendarEventRespEventEndTime    `json:"end_time,omitempty"`           // 日程结束时间
	Vchat            *CreateCalendarEventRespEventVchat      `json:"vchat,omitempty"`              // 视频会议信息。
	Visibility       string                                  `json:"visibility,omitempty"`         // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  string                                  `json:"attendee_ability,omitempty"`   // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   string                                  `json:"free_busy_status,omitempty"`   // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location         *CreateCalendarEventRespEventLocation   `json:"location,omitempty"`           // 日程地点
	Color            int64                                   `json:"color,omitempty"`              // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders        []*CreateCalendarEventRespEventReminder `json:"reminders,omitempty"`          // 日程提醒列表
	Recurrence       string                                  `json:"recurrence,omitempty"`         // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。
	Status           string                                  `json:"status,omitempty"`             // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException      bool                                    `json:"is_exception,omitempty"`       // 日程是否是一个重复日程的例外日程
	RecurringEventID string                                  `json:"recurring_event_id,omitempty"` // 例外日程的原重复日程的event_id
	Schemas          []*CreateCalendarEventRespEventSchema   `json:"schemas,omitempty"`            // 日程自定义信息
}

type CreateCalendarEventRespEventStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type CreateCalendarEventRespEventEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type CreateCalendarEventRespEventVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：Lark直播，内部类型，只读。, `unknown`：未知类型，做兼容使用，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL
}

type CreateCalendarEventRespEventLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称
	Address   string  `json:"address,omitempty"`   // 地点地址
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

type CreateCalendarEventRespEventReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效
}

type CreateCalendarEventRespEventSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： \,ForwardIcon: 日程转发按钮 \,MeetingChatIcon: 会议群聊按钮 \,MeetingMinutesIcon: 会议纪要按钮 \,MeetingVideo: 视频会议区域 \,RSVP: 接受/拒绝/待定区域 \,Attendee: 参与者区域 \,OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。目前只支持hide, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendarEvent
//
// 该接口用于以当前身份（应用 / 用户）删除日历上的一个日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// 当前身份必须是日程的组织者。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/delete
func (r *CalendarService) DeleteCalendarEvent(ctx context.Context, request *DeleteCalendarEventReq, options ...MethodOptionFunc) (*DeleteCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarEvent mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarEvent",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarDeleteCalendarEvent(f func(ctx context.Context, request *DeleteCalendarEventReq, options ...MethodOptionFunc) (*DeleteCalendarEventResp, *Response, error)) {
	r.mockCalendarDeleteCalendarEvent = f
}

func (r *Mock) UnMockCalendarDeleteCalendarEvent() {
	r.mockCalendarDeleteCalendarEvent = nil
}

type DeleteCalendarEventReq struct {
	NeedNotification *bool  `query:"need_notification" json:"-"` // 删除日程是否给日程参与人发送bot通知，默认为true, 示例值：false, 可选值有: `true`：true, `false`：false
	CalendarID       string `path:"calendar_id" json:"-"`        // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string `path:"event_id" json:"-"`           // 日程ID, 示例值："xxxxxxxxx_0"
}

type deleteCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarEventResp `json:"data,omitempty"`
}

type DeleteCalendarEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEvent 该接口用于以当前身份（应用 / 用户）获取日历上的一个日程。
//
// 当前身份必须对日历有访问权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/get
func (r *CalendarService) GetCalendarEvent(ctx context.Context, request *GetCalendarEventReq, options ...MethodOptionFunc) (*GetCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEvent mock enable")
		return r.cli.mock.mockCalendarGetCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEvent",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendarEvent(f func(ctx context.Context, request *GetCalendarEventReq, options ...MethodOptionFunc) (*GetCalendarEventResp, *Response, error)) {
	r.mockCalendarGetCalendarEvent = f
}

func (r *Mock) UnMockCalendarGetCalendarEvent() {
	r.mockCalendarGetCalendarEvent = nil
}

type GetCalendarEventReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID    string `path:"event_id" json:"-"`    // 日程ID, 示例值："xxxxxxxxx_0"
}

type getCalendarEventResp struct {
	Code int64                 `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventResp `json:"data,omitempty"`
}

type GetCalendarEventResp struct {
	Event *GetCalendarEventRespEvent `json:"event,omitempty"` // 日程实体
}

type GetCalendarEventRespEvent struct {
	EventID          string                               `json:"event_id,omitempty"`           // 日程ID
	Summary          string                               `json:"summary,omitempty"`            // 日程标题, 最大长度：`1000` 字符
	Description      string                               `json:"description,omitempty"`        // 日程描述, 最大长度：`8192` 字符
	StartTime        *GetCalendarEventRespEventStartTime  `json:"start_time,omitempty"`         // 日程开始时间
	EndTime          *GetCalendarEventRespEventEndTime    `json:"end_time,omitempty"`           // 日程结束时间
	Vchat            *GetCalendarEventRespEventVchat      `json:"vchat,omitempty"`              // 视频会议信息。
	Visibility       string                               `json:"visibility,omitempty"`         // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  string                               `json:"attendee_ability,omitempty"`   // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   string                               `json:"free_busy_status,omitempty"`   // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location         *GetCalendarEventRespEventLocation   `json:"location,omitempty"`           // 日程地点
	Color            int64                                `json:"color,omitempty"`              // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders        []*GetCalendarEventRespEventReminder `json:"reminders,omitempty"`          // 日程提醒列表
	Recurrence       string                               `json:"recurrence,omitempty"`         // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。, 最大长度：`2000` 字符
	Status           string                               `json:"status,omitempty"`             // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException      bool                                 `json:"is_exception,omitempty"`       // 日程是否是一个重复日程的例外日程
	RecurringEventID string                               `json:"recurring_event_id,omitempty"` // 例外日程的原重复日程的event_id
	Schemas          []*GetCalendarEventRespEventSchema   `json:"schemas,omitempty"`            // 日程自定义信息
}

type GetCalendarEventRespEventStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type GetCalendarEventRespEventEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type GetCalendarEventRespEventVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：Lark直播，内部类型，只读。, `unknown`：未知类型，做兼容使用，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案, 长度范围：`0` ～ `500` 字符
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL, 长度范围：`1` ～ `2000` 字符
}

type GetCalendarEventRespEventLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称, 长度范围：`1` ～ `512` 字符
	Address   string  `json:"address,omitempty"`   // 地点地址, 长度范围：`1` ～ `255` 字符
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

type GetCalendarEventRespEventReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效, 取值范围：`-20160` ～ `20160`
}

type GetCalendarEventRespEventSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： \,ForwardIcon: 日程转发按钮 \,MeetingChatIcon: 会议群聊按钮 \,MeetingMinutesIcon: 会议纪要按钮 \,MeetingVideo: 视频会议区域 \,RSVP: 接受/拒绝/待定区域 \,Attendee: 参与者区域 \,OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。目前只支持hide, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接, 最大长度：`2000` 字符
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEventList 该接口用于以当前身份（应用 / 用户）获取日历下的日程列表。
//
// 当前身份必须对日历有访问权限。
// 调用时首先使用 page_token 分页拉取存量数据，之后使用 sync_token 增量同步变更数据。
// 为了确保调用方日程同步数据的一致性，在使用sync_token时，不能同时使用start_time和end_time，否则可能造成日程数据缺失。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/list
func (r *CalendarService) GetCalendarEventList(ctx context.Context, request *GetCalendarEventListReq, options ...MethodOptionFunc) (*GetCalendarEventListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEventList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEventList mock enable")
		return r.cli.mock.mockCalendarGetCalendarEventList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEventList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendarEventList(f func(ctx context.Context, request *GetCalendarEventListReq, options ...MethodOptionFunc) (*GetCalendarEventListResp, *Response, error)) {
	r.mockCalendarGetCalendarEventList = f
}

func (r *Mock) UnMockCalendarGetCalendarEventList() {
	r.mockCalendarGetCalendarEventList = nil
}

type GetCalendarEventListReq struct {
	PageSize   *int64  `query:"page_size" json:"-"`   // 一次请求要求返回最大数量，默认500，取值范围为[50, 1000], 示例值：50, 默认值: `500`, 取值范围：`50` ～ `1000`
	AnchorTime *string `query:"anchor_time" json:"-"` // 拉取anchor_time之后的日程，为timestamp, 示例值："1609430400"
	PageToken  *string `query:"page_token" json:"-"`  // 上次请求Response返回的分页标记，首次请求时为空, 示例值："ListCalendarsPageToken_1632452910_1632539310"
	SyncToken  *string `query:"sync_token" json:"-"`  // 上次请求Response返回的增量同步标记，分页请求未结束时为空, 示例值："ListCalendarsSyncToken_1632452910"
	StartTime  *string `query:"start_time" json:"-"`  // 日程开始Unix时间戳，单位为秒, 示例值："1631777271"
	EndTime    *string `query:"end_time" json:"-"`    // 日程结束Unix时间戳，单位为秒, 示例值："1631777271"
	CalendarID string  `path:"calendar_id" json:"-"`  // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type getCalendarEventListResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventListResp `json:"data,omitempty"`
}

type GetCalendarEventListResp struct {
	HasMore   bool                            `json:"has_more,omitempty"`   // 是否有下一页数据
	PageToken string                          `json:"page_token,omitempty"` // 下次请求需要带上的分页标记，90 天有效期
	SyncToken string                          `json:"sync_token,omitempty"` // 下次请求需要带上的增量同步标记，90 天有效期
	Items     []*GetCalendarEventListRespItem `json:"items,omitempty"`      // 日程列表
}

type GetCalendarEventListRespItem struct {
	EventID          string                                  `json:"event_id,omitempty"`           // 日程ID
	Summary          string                                  `json:"summary,omitempty"`            // 日程标题
	Description      string                                  `json:"description,omitempty"`        // 日程描述
	StartTime        *GetCalendarEventListRespItemStartTime  `json:"start_time,omitempty"`         // 日程开始时间
	EndTime          *GetCalendarEventListRespItemEndTime    `json:"end_time,omitempty"`           // 日程结束时间
	Vchat            *GetCalendarEventListRespItemVchat      `json:"vchat,omitempty"`              // 视频会议信息。
	Visibility       string                                  `json:"visibility,omitempty"`         // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  string                                  `json:"attendee_ability,omitempty"`   // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   string                                  `json:"free_busy_status,omitempty"`   // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location         *GetCalendarEventListRespItemLocation   `json:"location,omitempty"`           // 日程地点
	Color            int64                                   `json:"color,omitempty"`              // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders        []*GetCalendarEventListRespItemReminder `json:"reminders,omitempty"`          // 日程提醒列表
	Recurrence       string                                  `json:"recurrence,omitempty"`         // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。
	Status           string                                  `json:"status,omitempty"`             // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException      bool                                    `json:"is_exception,omitempty"`       // 日程是否是一个重复日程的例外日程
	RecurringEventID string                                  `json:"recurring_event_id,omitempty"` // 例外日程的原重复日程的event_id
	Schemas          []*GetCalendarEventListRespItemSchema   `json:"schemas,omitempty"`            // 日程自定义信息
}

type GetCalendarEventListRespItemStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type GetCalendarEventListRespItemEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type GetCalendarEventListRespItemVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：Lark直播，内部类型，只读。, `unknown`：未知类型，做兼容使用，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL
}

type GetCalendarEventListRespItemLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称
	Address   string  `json:"address,omitempty"`   // 地点地址
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

type GetCalendarEventListRespItemReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效
}

type GetCalendarEventListRespItemSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： \,ForwardIcon: 日程转发按钮 \,MeetingChatIcon: 会议群聊按钮 \,MeetingMinutesIcon: 会议纪要按钮 \,MeetingVideo: 视频会议区域 \,RSVP: 接受/拒绝/待定区域 \,Attendee: 参与者区域 \,OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。目前只支持hide, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateCalendarEvent
//
// 该接口用于以当前身份（应用 / 用户）更新日历上的一个日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// 当前身份为日程组织者时，可修改所有可编辑字段。
// 当前身份为日程参与者时，仅可编辑部分字段。（如：visibility, free_busy_status, color, reminders）
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/patch
func (r *CalendarService) UpdateCalendarEvent(ctx context.Context, request *UpdateCalendarEventReq, options ...MethodOptionFunc) (*UpdateCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarUpdateCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#UpdateCalendarEvent mock enable")
		return r.cli.mock.mockCalendarUpdateCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "UpdateCalendarEvent",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarUpdateCalendarEvent(f func(ctx context.Context, request *UpdateCalendarEventReq, options ...MethodOptionFunc) (*UpdateCalendarEventResp, *Response, error)) {
	r.mockCalendarUpdateCalendarEvent = f
}

func (r *Mock) UnMockCalendarUpdateCalendarEvent() {
	r.mockCalendarUpdateCalendarEvent = nil
}

type UpdateCalendarEventReq struct {
	CalendarID       string                            `path:"calendar_id" json:"-"`        // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string                            `path:"event_id" json:"-"`           // 日程ID, 示例值："xxxxxxxxx_0"
	Summary          *string                           `json:"summary,omitempty"`           // 日程标题, 示例值："日程标题", 最大长度：`1000` 字符
	Description      *string                           `json:"description,omitempty"`       // 日程描述, 示例值："日程描述", 最大长度：`8192` 字符
	NeedNotification *bool                             `json:"need_notification,omitempty"` // 更新日程是否给日程参与人发送bot通知，默认为true, 示例值：false
	StartTime        *UpdateCalendarEventReqStartTime  `json:"start_time,omitempty"`        // 日程开始时间
	EndTime          *UpdateCalendarEventReqEndTime    `json:"end_time,omitempty"`          // 日程结束时间
	Vchat            *UpdateCalendarEventReqVchat      `json:"vchat,omitempty"`             // 视频会议信息。
	Visibility       *string                           `json:"visibility,omitempty"`        // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："default", 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  *string                           `json:"attendee_ability,omitempty"`  // 参与人权限, 示例值："can_see_others", 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   *string                           `json:"free_busy_status,omitempty"`  // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："busy", 可选值有: `busy`：忙碌, `free`：空闲
	Location         *UpdateCalendarEventReqLocation   `json:"location,omitempty"`          // 日程地点
	Color            *int64                            `json:"color,omitempty"`             // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。, 示例值：-1
	Reminders        []*UpdateCalendarEventReqReminder `json:"reminders,omitempty"`         // 日程提醒列表
	Recurrence       *string                           `json:"recurrence,omitempty"`        // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。, 示例值："FREQ=DAILY;INTERVAL=1", 最大长度：`2000` 字符
	Schemas          []*UpdateCalendarEventReqSchema   `json:"schemas,omitempty"`           // 日程自定义信息
}

type UpdateCalendarEventReqStartTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1605024000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

type UpdateCalendarEventReqEndTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1605024000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

type UpdateCalendarEventReqVchat struct {
	VCType      *string `json:"vc_type,omitempty"`     // 视频会议类型, 示例值："third_party", 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：Lark直播，内部类型，只读。, `unknown`：未知类型，做兼容使用，只读。
	IconType    *string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 示例值："vc", 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description *string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案, 示例值："发起视频会议", 长度范围：`0` ～ `500` 字符
	MeetingURL  *string `json:"meeting_url,omitempty"` // 视频会议URL, 示例值："https://example.com", 长度范围：`1` ～ `2000` 字符
}

type UpdateCalendarEventReqLocation struct {
	Name      *string  `json:"name,omitempty"`      // 地点名称, 示例值："地点名称", 长度范围：`1` ～ `512` 字符
	Address   *string  `json:"address,omitempty"`   // 地点地址, 示例值："地点地址", 长度范围：`1` ～ `255` 字符
	Latitude  *float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：1.100000023841858
	Longitude *float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：2.200000047683716
}

type UpdateCalendarEventReqReminder struct {
	Minutes *int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效, 示例值：5, 取值范围：`-20160` ～ `20160`
}

type UpdateCalendarEventReqSchema struct {
	UiName   *string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： \,ForwardIcon: 日程转发按钮 \,MeetingChatIcon: 会议群聊按钮 \,MeetingMinutesIcon: 会议纪要按钮 \,MeetingVideo: 视频会议区域 \,RSVP: 接受/拒绝/待定区域 \,Attendee: 参与者区域 \,OrganizerOrCreator: 组织者/创建者区域, 示例值："ForwardIcon"
	UiStatus *string `json:"ui_status,omitempty"` // UI项自定义状态。目前只支持hide, 示例值："hide", 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  *string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接, 示例值："https://applink.feishu.cn/client/calendar/event/detail?calendarId=xxxxxx&key=xxxxxx&originalTime=xxxxxx&startTime=xxxxxx", 最大长度：`2000` 字符
}

type updateCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *UpdateCalendarEventResp `json:"data,omitempty"`
}

type UpdateCalendarEventResp struct {
	Event *UpdateCalendarEventRespEvent `json:"event,omitempty"` // 更新后的日程实体
}

type UpdateCalendarEventRespEvent struct {
	EventID          string                                  `json:"event_id,omitempty"`           // 日程ID
	Summary          string                                  `json:"summary,omitempty"`            // 日程标题, 最大长度：`1000` 字符
	Description      string                                  `json:"description,omitempty"`        // 日程描述, 最大长度：`8192` 字符
	NeedNotification bool                                    `json:"need_notification,omitempty"`  // 更新日程是否给日程参与人发送bot通知，默认为true
	StartTime        *UpdateCalendarEventRespEventStartTime  `json:"start_time,omitempty"`         // 日程开始时间
	EndTime          *UpdateCalendarEventRespEventEndTime    `json:"end_time,omitempty"`           // 日程结束时间
	Vchat            *UpdateCalendarEventRespEventVchat      `json:"vchat,omitempty"`              // 视频会议信息。
	Visibility       string                                  `json:"visibility,omitempty"`         // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  string                                  `json:"attendee_ability,omitempty"`   // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   string                                  `json:"free_busy_status,omitempty"`   // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location         *UpdateCalendarEventRespEventLocation   `json:"location,omitempty"`           // 日程地点
	Color            int64                                   `json:"color,omitempty"`              // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders        []*UpdateCalendarEventRespEventReminder `json:"reminders,omitempty"`          // 日程提醒列表
	Recurrence       string                                  `json:"recurrence,omitempty"`         // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。, 最大长度：`2000` 字符
	Status           string                                  `json:"status,omitempty"`             // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException      bool                                    `json:"is_exception,omitempty"`       // 日程是否是一个重复日程的例外日程
	RecurringEventID string                                  `json:"recurring_event_id,omitempty"` // 例外日程的原重复日程的event_id
	Schemas          []*UpdateCalendarEventRespEventSchema   `json:"schemas,omitempty"`            // 日程自定义信息
}

type UpdateCalendarEventRespEventStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type UpdateCalendarEventRespEventEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type UpdateCalendarEventRespEventVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：Lark直播，内部类型，只读。, `unknown`：未知类型，做兼容使用，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案, 长度范围：`0` ～ `500` 字符
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL, 长度范围：`1` ～ `2000` 字符
}

type UpdateCalendarEventRespEventLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称, 长度范围：`1` ～ `512` 字符
	Address   string  `json:"address,omitempty"`   // 地点地址, 长度范围：`1` ～ `255` 字符
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

type UpdateCalendarEventRespEventReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效, 取值范围：`-20160` ～ `20160`
}

type UpdateCalendarEventRespEventSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： \,ForwardIcon: 日程转发按钮 \,MeetingChatIcon: 会议群聊按钮 \,MeetingMinutesIcon: 会议纪要按钮 \,MeetingVideo: 视频会议区域 \,RSVP: 接受/拒绝/待定区域 \,Attendee: 参与者区域 \,OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。目前只支持hide, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接, 最大长度：`2000` 字符
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SearchCalendarEvent
//
// 该接口用于以用户身份搜索某日历下的相关日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有访问权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/search
func (r *CalendarService) SearchCalendarEvent(ctx context.Context, request *SearchCalendarEventReq, options ...MethodOptionFunc) (*SearchCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarSearchCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SearchCalendarEvent mock enable")
		return r.cli.mock.mockCalendarSearchCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SearchCalendarEvent",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/search",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(searchCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarSearchCalendarEvent(f func(ctx context.Context, request *SearchCalendarEventReq, options ...MethodOptionFunc) (*SearchCalendarEventResp, *Response, error)) {
	r.mockCalendarSearchCalendarEvent = f
}

func (r *Mock) UnMockCalendarSearchCalendarEvent() {
	r.mockCalendarSearchCalendarEvent = nil
}

type SearchCalendarEventReq struct {
	UserIDType *IDType                       `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`,, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	PageToken  *string                       `query:"page_token" json:"-"`   // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："xxxxx"
	PageSize   *int64                        `query:"page_size" json:"-"`    // 分页大小, 示例值：10, 最大值：`100`
	CalendarID string                        `path:"calendar_id" json:"-"`   // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	Query      string                        `json:"query,omitempty"`        // 搜索关键字, 示例值："query words", 长度范围：`1` ～ `200` 字符
	Filter     *SearchCalendarEventReqFilter `json:"filter,omitempty"`       // 搜索过滤器
}

type SearchCalendarEventReqFilter struct {
	StartTime *SearchCalendarEventReqFilterStartTime `json:"start_time,omitempty"` // 搜索过滤项，日程搜索区间的开始时间，被搜索日程的事件必须与搜索区间有交集
	EndTime   *SearchCalendarEventReqFilterEndTime   `json:"end_time,omitempty"`   // 搜索过滤项，日程搜索区间的结束时间，被搜索日程的事件必须与搜索区间有交集
	UserIDs   []string                               `json:"user_ids,omitempty"`   // 搜索过滤项，参与人的用户ID列表，被搜索日程中必须包含至少一个其中的参与人, 示例值：xxxxx
	RoomIDs   []string                               `json:"room_ids,omitempty"`   // 搜索过滤项，会议室ID列表，被搜索日程中必须包含至少一个其中的会议室, 示例值：xxxxx
	ChatIDs   []string                               `json:"chat_ids,omitempty"`   // 搜索过滤项，群ID列表，被搜索日程的参与人中必须包含至少一个其中的群, 示例值：xxxxx
}

type SearchCalendarEventReqFilterStartTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1605024000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

type SearchCalendarEventReqFilterEndTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1605024000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

type searchCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *SearchCalendarEventResp `json:"data,omitempty"`
}

type SearchCalendarEventResp struct {
	Items     []*SearchCalendarEventRespItem `json:"items,omitempty"`      // 搜索命中的日程列表
	PageToken string                         `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

type SearchCalendarEventRespItem struct {
	EventID          string                                 `json:"event_id,omitempty"`           // 日程ID
	Summary          string                                 `json:"summary,omitempty"`            // 日程标题, 最大长度：`1000` 字符
	Description      string                                 `json:"description,omitempty"`        // 日程描述, 最大长度：`8192` 字符
	NeedNotification bool                                   `json:"need_notification,omitempty"`  // 更新日程是否给日程参与人发送bot通知，默认为true
	StartTime        *SearchCalendarEventRespItemStartTime  `json:"start_time,omitempty"`         // 日程开始时间
	EndTime          *SearchCalendarEventRespItemEndTime    `json:"end_time,omitempty"`           // 日程结束时间
	Vchat            *SearchCalendarEventRespItemVchat      `json:"vchat,omitempty"`              // 视频会议信息。
	Visibility       string                                 `json:"visibility,omitempty"`         // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  string                                 `json:"attendee_ability,omitempty"`   // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   string                                 `json:"free_busy_status,omitempty"`   // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location         *SearchCalendarEventRespItemLocation   `json:"location,omitempty"`           // 日程地点
	Color            int64                                  `json:"color,omitempty"`              // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders        []*SearchCalendarEventRespItemReminder `json:"reminders,omitempty"`          // 日程提醒列表
	Recurrence       string                                 `json:"recurrence,omitempty"`         // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。, 最大长度：`2000` 字符
	Status           string                                 `json:"status,omitempty"`             // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException      bool                                   `json:"is_exception,omitempty"`       // 日程是否是一个重复日程的例外日程
	RecurringEventID string                                 `json:"recurring_event_id,omitempty"` // 例外日程的原重复日程的event_id
	Schemas          []*SearchCalendarEventRespItemSchema   `json:"schemas,omitempty"`            // 日程自定义信息
}

type SearchCalendarEventRespItemStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type SearchCalendarEventRespItemEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

type SearchCalendarEventRespItemVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：Lark直播，内部类型，只读。, `unknown`：未知类型，做兼容使用，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案, 长度范围：`0` ～ `500` 字符
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL, 长度范围：`1` ～ `2000` 字符
}

type SearchCalendarEventRespItemLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称, 长度范围：`1` ～ `512` 字符
	Address   string  `json:"address,omitempty"`   // 地点地址, 长度范围：`1` ～ `255` 字符
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

type SearchCalendarEventRespItemReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效, 取值范围：`-20160` ～ `20160`
}

type SearchCalendarEventRespItemSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： \,ForwardIcon: 日程转发按钮 \,MeetingChatIcon: 会议群聊按钮 \,MeetingMinutesIcon: 会议纪要按钮 \,MeetingVideo: 视频会议区域 \,RSVP: 接受/拒绝/待定区域 \,Attendee: 参与者区域 \,OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。目前只支持hide, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接, 最大长度：`2000` 字符
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendarEvent 该接口用于以用户身份订阅指定日历下的日程变更事件。
//
// 用户必须对日历有访问权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/subscription
func (r *CalendarService) SubscribeCalendarEvent(ctx context.Context, request *SubscribeCalendarEventReq, options ...MethodOptionFunc) (*SubscribeCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendarEvent mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SubscribeCalendarEvent",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/subscription",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(subscribeCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarSubscribeCalendarEvent(f func(ctx context.Context, request *SubscribeCalendarEventReq, options ...MethodOptionFunc) (*SubscribeCalendarEventResp, *Response, error)) {
	r.mockCalendarSubscribeCalendarEvent = f
}

func (r *Mock) UnMockCalendarSubscribeCalendarEvent() {
	r.mockCalendarSubscribeCalendarEvent = nil
}

type SubscribeCalendarEventReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type subscribeCalendarEventResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarEventResp `json:"data,omitempty"`
}

type SubscribeCalendarEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarFreeBusyList 查询用户主日历或会议室的忙闲信息。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/freebusy/list
func (r *CalendarService) GetCalendarFreeBusyList(ctx context.Context, request *GetCalendarFreeBusyListReq, options ...MethodOptionFunc) (*GetCalendarFreeBusyListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarFreeBusyList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarFreeBusyList mock enable")
		return r.cli.mock.mockCalendarGetCalendarFreeBusyList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarFreeBusyList",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/freebusy/list",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getCalendarFreeBusyListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendarFreeBusyList(f func(ctx context.Context, request *GetCalendarFreeBusyListReq, options ...MethodOptionFunc) (*GetCalendarFreeBusyListResp, *Response, error)) {
	r.mockCalendarGetCalendarFreeBusyList = f
}

func (r *Mock) UnMockCalendarGetCalendarFreeBusyList() {
	r.mockCalendarGetCalendarFreeBusyList = nil
}

type GetCalendarFreeBusyListReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	TimeMin    string  `json:"time_min,omitempty"`     // 查询时段开始时间，需要url编码, 示例值："2020-10-28T12:00:00+08:00"
	TimeMax    string  `json:"time_max,omitempty"`     // 查询时段结束时间，需要url编码, 示例值："2020-12-28T12:00:00+08:00"
	UserID     *string `json:"user_id,omitempty"`      // 用户user_id，输入时与 room_id 二选一, 示例值："ou_xxxxxxxxxx"
	RoomID     *string `json:"room_id,omitempty"`      // 会议室room_id，输入时与 user_id 二选一, 示例值："omm_xxxxxxxxxx"
}

type getCalendarFreeBusyListResp struct {
	Code int64                        `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                       `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarFreeBusyListResp `json:"data,omitempty"`
}

type GetCalendarFreeBusyListResp struct {
	FreebusyList []*GetCalendarFreeBusyListRespFreebusy `json:"freebusy_list,omitempty"` // 日历上请求时间区间内的忙碌时间段信息。
}

type GetCalendarFreeBusyListRespFreebusy struct {
	StartTime string `json:"start_time,omitempty"` // 忙闲信息开始时间，RFC3339 date_time 格式
	EndTime   string `json:"end_time,omitempty"`   // 忙闲信息结束时间，RFC3339 date_time 格式
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendar
//
// 该接口用于以当前身份（应用 / 用户）根据日历 ID 获取日历信息。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有访问权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/get
func (r *CalendarService) GetCalendar(ctx context.Context, request *GetCalendarReq, options ...MethodOptionFunc) (*GetCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendar mock enable")
		return r.cli.mock.mockCalendarGetCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendar",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendar(f func(ctx context.Context, request *GetCalendarReq, options ...MethodOptionFunc) (*GetCalendarResp, *Response, error)) {
	r.mockCalendarGetCalendar = f
}

func (r *Mock) UnMockCalendarGetCalendar() {
	r.mockCalendarGetCalendar = nil
}

type GetCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type getCalendarResp struct {
	Code int64            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string           `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarResp `json:"data,omitempty"`
}

type GetCalendarResp struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID
	Summary      string             `json:"summary,omitempty"`        // 日历标题, 最大长度：`255` 字符
	Description  string             `json:"description,omitempty"`    // 日历描述, 最大长度：`255` 字符
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效, 最大长度：`255` 字符
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除, 默认值: `false`
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入, 默认值: `false`
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarList
//
// 该接口用于分页获得当前身份（应用 / 用户）的日历列表。
// 身份由 Header Authorization 的 Token 类型决定。
// 调用时首先使用 page_token 分页拉取存量数据，之后使用 sync_token 增量同步变更数据。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/list
func (r *CalendarService) GetCalendarList(ctx context.Context, request *GetCalendarListReq, options ...MethodOptionFunc) (*GetCalendarListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarList mock enable")
		return r.cli.mock.mockCalendarGetCalendarList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGetCalendarList(f func(ctx context.Context, request *GetCalendarListReq, options ...MethodOptionFunc) (*GetCalendarListResp, *Response, error)) {
	r.mockCalendarGetCalendarList = f
}

func (r *Mock) UnMockCalendarGetCalendarList() {
	r.mockCalendarGetCalendarList = nil
}

type GetCalendarListReq struct {
	PageSize  *int64  `query:"page_size" json:"-"`  // 一次请求要求返回最大数量，默认500，取值范围为[50. 1000], 示例值：10, 默认值: `500`, 取值范围：`50` ～ `1000`
	PageToken *string `query:"page_token" json:"-"` // 上次请求Response返回的分页标记，首次请求时为空, 示例值："xxxxx"
	SyncToken *string `query:"sync_token" json:"-"` // 上次请求Response返回的增量同步标记，分页请求未结束时为空, 示例值："ListCalendarsSyncToken_xxx"
}

type getCalendarListResp struct {
	Code int64                `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string               `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarListResp `json:"data,omitempty"`
}

type GetCalendarListResp struct {
	HasMore      bool                           `json:"has_more,omitempty"`      // 是否有下一页数据
	PageToken    string                         `json:"page_token,omitempty"`    // 下次请求需要带上的分页标记，90 天有效期
	SyncToken    string                         `json:"sync_token,omitempty"`    // 下次请求需要带上的增量同步标记，90 天有效期
	CalendarList []*GetCalendarListRespCalendar `json:"calendar_list,omitempty"` // 分页加载的日历数据列表
}

type GetCalendarListRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID
	Summary      string             `json:"summary,omitempty"`        // 日历标题, 最大长度：`255` 字符
	Description  string             `json:"description,omitempty"`    // 日历描述, 最大长度：`255` 字符
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效, 最大长度：`255` 字符
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除, 默认值: `false`
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入, 默认值: `false`
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateCalendar
//
// 该接口用于以当前身份（应用 / 用户）修改日历信息。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份对日历有 owner 权限时，可修改全局字段：summary, description, permission。
// 当前身份对日历不具有 owner 权限时，仅可修改对自己生效的字段：color, summary_alias。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/patch
func (r *CalendarService) UpdateCalendar(ctx context.Context, request *UpdateCalendarReq, options ...MethodOptionFunc) (*UpdateCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarUpdateCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#UpdateCalendar mock enable")
		return r.cli.mock.mockCalendarUpdateCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "UpdateCalendar",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarUpdateCalendar(f func(ctx context.Context, request *UpdateCalendarReq, options ...MethodOptionFunc) (*UpdateCalendarResp, *Response, error)) {
	r.mockCalendarUpdateCalendar = f
}

func (r *Mock) UnMockCalendarUpdateCalendar() {
	r.mockCalendarUpdateCalendar = nil
}

type UpdateCalendarReq struct {
	CalendarID   string              `path:"calendar_id" json:"-"`    // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	Summary      *string             `json:"summary,omitempty"`       // 日历标题, 示例值："测试日历", 长度范围：`1` ～ `255` 字符
	Description  *string             `json:"description,omitempty"`   // 日历描述, 示例值："使用开放接口创建日历", 最大长度：`255` 字符
	Permissions  *CalendarPermission `json:"permissions,omitempty"`   // 日历公开范围, 示例值："private", 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        *int64              `json:"color,omitempty"`         // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效, 示例值：-1
	SummaryAlias *string             `json:"summary_alias,omitempty"` // 日历备注名，修改或添加后仅对当前身份生效, 示例值："日历备注名", 最大长度：`255` 字符
}

type updateCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *UpdateCalendarResp `json:"data,omitempty"`
}

type UpdateCalendarResp struct {
	Calendar *UpdateCalendarRespCalendar `json:"calendar,omitempty"` // 更新后的日历实体
}

type UpdateCalendarRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID
	Summary      string             `json:"summary,omitempty"`        // 日历标题, 最大长度：`255` 字符
	Description  string             `json:"description,omitempty"`    // 日历描述, 最大长度：`255` 字符
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效, 最大长度：`255` 字符
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除, 默认值: `false`
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入, 默认值: `false`
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SearchCalendar 该接口用于通过关键字查询公共日历或用户主日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/search
func (r *CalendarService) SearchCalendar(ctx context.Context, request *SearchCalendarReq, options ...MethodOptionFunc) (*SearchCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarSearchCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SearchCalendar mock enable")
		return r.cli.mock.mockCalendarSearchCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "SearchCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/search",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(searchCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarSearchCalendar(f func(ctx context.Context, request *SearchCalendarReq, options ...MethodOptionFunc) (*SearchCalendarResp, *Response, error)) {
	r.mockCalendarSearchCalendar = f
}

func (r *Mock) UnMockCalendarSearchCalendar() {
	r.mockCalendarSearchCalendar = nil
}

type SearchCalendarReq struct {
	PageToken *string `query:"page_token" json:"-"` // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："xxxxx"
	PageSize  *int64  `query:"page_size" json:"-"`  // 分页大小, 示例值：10, 最大值：`50`
	Query     string  `json:"query,omitempty"`      // 搜索关键字, 示例值："query words", 长度范围：`1` ～ `200` 字符
}

type searchCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *SearchCalendarResp `json:"data,omitempty"`
}

type SearchCalendarResp struct {
	Items     []*SearchCalendarRespItem `json:"items,omitempty"`      // 搜索命中的日历列表
	PageToken string                    `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

type SearchCalendarRespItem struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID
	Summary      string             `json:"summary,omitempty"`        // 日历标题, 最大长度：`255` 字符
	Description  string             `json:"description,omitempty"`    // 日历描述, 最大长度：`255` 字符
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效, 最大长度：`255` 字符
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除, 默认值: `false`
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入, 默认值: `false`
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendar
//
// 该接口用于以当前身份（应用 / 用户）订阅某个日历。
// 身份由 Header Authorization 的 Token 类型决定。
// 仅可订阅类型为 primary 或 shared 的公开日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/subscribe
func (r *CalendarService) SubscribeCalendar(ctx context.Context, request *SubscribeCalendarReq, options ...MethodOptionFunc) (*SubscribeCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendar mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "SubscribeCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/subscribe",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(subscribeCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarSubscribeCalendar(f func(ctx context.Context, request *SubscribeCalendarReq, options ...MethodOptionFunc) (*SubscribeCalendarResp, *Response, error)) {
	r.mockCalendarSubscribeCalendar = f
}

func (r *Mock) UnMockCalendarSubscribeCalendar() {
	r.mockCalendarSubscribeCalendar = nil
}

type SubscribeCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type subscribeCalendarResp struct {
	Code int64                  `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarResp `json:"data,omitempty"`
}

type SubscribeCalendarResp struct {
	Calendar *SubscribeCalendarRespCalendar `json:"calendar,omitempty"` // 订阅的日历实体
}

type SubscribeCalendarRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID
	Summary      string             `json:"summary,omitempty"`        // 日历标题, 最大长度：`255` 字符
	Description  string             `json:"description,omitempty"`    // 日历描述, 最大长度：`255` 字符
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效, 最大长度：`255` 字符
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除, 默认值: `false`
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入, 默认值: `false`
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendarChangeEvent 该接口用于以用户身份订阅当前身份下日历列表中的所有日历变更。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/subscription
func (r *CalendarService) SubscribeCalendarChangeEvent(ctx context.Context, request *SubscribeCalendarChangeEventReq, options ...MethodOptionFunc) (*SubscribeCalendarChangeEventResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendarChangeEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendarChangeEvent mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendarChangeEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SubscribeCalendarChangeEvent",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/subscription",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(subscribeCalendarChangeEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarSubscribeCalendarChangeEvent(f func(ctx context.Context, request *SubscribeCalendarChangeEventReq, options ...MethodOptionFunc) (*SubscribeCalendarChangeEventResp, *Response, error)) {
	r.mockCalendarSubscribeCalendarChangeEvent = f
}

func (r *Mock) UnMockCalendarSubscribeCalendarChangeEvent() {
	r.mockCalendarSubscribeCalendarChangeEvent = nil
}

type SubscribeCalendarChangeEventReq struct{}

type subscribeCalendarChangeEventResp struct {
	Code int64                             `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                            `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarChangeEventResp `json:"data,omitempty"`
}

type SubscribeCalendarChangeEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendarTimeoffEvent 为指定用户创建一个请假日程，可以是一个普通请假日程，也可以是一个全天日程。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/timeoff_event/create
func (r *CalendarService) CreateCalendarTimeoffEvent(ctx context.Context, request *CreateCalendarTimeoffEventReq, options ...MethodOptionFunc) (*CreateCalendarTimeoffEventResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendarTimeoffEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendarTimeoffEvent mock enable")
		return r.cli.mock.mockCalendarCreateCalendarTimeoffEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendarTimeoffEvent",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/timeoff_events",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(createCalendarTimeoffEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarCreateCalendarTimeoffEvent(f func(ctx context.Context, request *CreateCalendarTimeoffEventReq, options ...MethodOptionFunc) (*CreateCalendarTimeoffEventResp, *Response, error)) {
	r.mockCalendarCreateCalendarTimeoffEvent = f
}

func (r *Mock) UnMockCalendarCreateCalendarTimeoffEvent() {
	r.mockCalendarCreateCalendarTimeoffEvent = nil
}

type CreateCalendarTimeoffEventReq struct {
	UserIDType  *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	UserID      string  `json:"user_id,omitempty"`      // 用户id, 示例值："ou_XXXXXXXXXX"
	Timezone    string  `json:"timezone,omitempty"`     // 时区, 示例值："Asia/Shanghai"
	StartTime   string  `json:"start_time,omitempty"`   // 休假开始时间: 有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。, 示例值："2021-01-01"
	EndTime     string  `json:"end_time,omitempty"`     // 休假结束时间：,有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。, 示例值："2021-01-01"
	Title       *string `json:"title,omitempty"`        // 自定义请假日程标题，没有设置则为默认日程标题, 示例值："请假中(全天) / 1-Day Time Off"
	Description *string `json:"description,omitempty"`  // 自定义请假日程描述，没有设置则为默认日程描述, 示例值："若删除此日程，飞书中相应的“请假”标签将自动消失，而请假系统中的休假申请不会被撤销。"
}

type createCalendarTimeoffEventResp struct {
	Code int64                           `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                          `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarTimeoffEventResp `json:"data,omitempty"`
}

type CreateCalendarTimeoffEventResp struct {
	TimeoffEventID string `json:"timeoff_event_id,omitempty"` // 请假日程ID
	UserID         string `json:"user_id,omitempty"`          // 用户id
	Timezone       string `json:"timezone,omitempty"`         // 时区
	StartTime      string `json:"start_time,omitempty"`       // 休假开始时间: 有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。
	EndTime        string `json:"end_time,omitempty"`         // 休假结束时间：,有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。
	Title          string `json:"title,omitempty"`            // 自定义请假日程标题，没有设置则为默认日程标题
	Description    string `json:"description,omitempty"`      // 自定义请假日程描述，没有设置则为默认日程描述
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendarTimeoffEvent 删除一个指定的请假日程，请假日程删除，用户个人签名页的请假信息也会消失。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/timeoff_event/delete
func (r *CalendarService) DeleteCalendarTimeoffEvent(ctx context.Context, request *DeleteCalendarTimeoffEventReq, options ...MethodOptionFunc) (*DeleteCalendarTimeoffEventResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarTimeoffEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarTimeoffEvent mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarTimeoffEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarTimeoffEvent",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/timeoff_events/:timeoff_event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(deleteCalendarTimeoffEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarDeleteCalendarTimeoffEvent(f func(ctx context.Context, request *DeleteCalendarTimeoffEventReq, options ...MethodOptionFunc) (*DeleteCalendarTimeoffEventResp, *Response, error)) {
	r.mockCalendarDeleteCalendarTimeoffEvent = f
}

func (r *Mock) UnMockCalendarDeleteCalendarTimeoffEvent() {
	r.mockCalendarDeleteCalendarTimeoffEvent = nil
}

type DeleteCalendarTimeoffEventReq struct {
	TimeoffEventID string `path:"timeoff_event_id" json:"-"` // 休假申请的唯一标识id, 示例值："timeoff:XXXXXX-XXXX-0917-1623-aa493d591a39"
}

type deleteCalendarTimeoffEventResp struct {
	Code int64                           `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                          `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarTimeoffEventResp `json:"data,omitempty"`
}

type DeleteCalendarTimeoffEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UnsubscribeCalendar
//
// 该接口用于以当前身份（应用 / 用户）取消对某日历的订阅状态。
// 身份由 Header Authorization 的 Token 类型决定。
// 仅可操作已经被当前身份订阅的日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/unsubscribe
func (r *CalendarService) UnsubscribeCalendar(ctx context.Context, request *UnsubscribeCalendarReq, options ...MethodOptionFunc) (*UnsubscribeCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarUnsubscribeCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#UnsubscribeCalendar mock enable")
		return r.cli.mock.mockCalendarUnsubscribeCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "UnsubscribeCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/unsubscribe",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(unsubscribeCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarUnsubscribeCalendar(f func(ctx context.Context, request *UnsubscribeCalendarReq, options ...MethodOptionFunc) (*UnsubscribeCalendarResp, *Response, error)) {
	r.mockCalendarUnsubscribeCalendar = f
}

func (r *Mock) UnMockCalendarUnsubscribeCalendar() {
	r.mockCalendarUnsubscribeCalendar = nil
}

type UnsubscribeCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID, 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

type unsubscribeCalendarResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *UnsubscribeCalendarResp `json:"data,omitempty"`
}

type UnsubscribeCalendarResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GenerateCaldavConf 用于为当前用户生成一个CalDAV账号密码，用于将飞书日历信息同步到本地设备日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/setting/generate_caldav_conf
func (r *CalendarService) GenerateCaldavConf(ctx context.Context, request *GenerateCaldavConfReq, options ...MethodOptionFunc) (*GenerateCaldavConfResp, *Response, error) {
	if r.cli.mock.mockCalendarGenerateCaldavConf != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GenerateCaldavConf mock enable")
		return r.cli.mock.mockCalendarGenerateCaldavConf(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "GenerateCaldavConf",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/settings/generate_caldav_conf",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(generateCaldavConfResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockCalendarGenerateCaldavConf(f func(ctx context.Context, request *GenerateCaldavConfReq, options ...MethodOptionFunc) (*GenerateCaldavConfResp, *Response, error)) {
	r.mockCalendarGenerateCaldavConf = f
}

func (r *Mock) UnMockCalendarGenerateCaldavConf() {
	r.mockCalendarGenerateCaldavConf = nil
}

type GenerateCaldavConfReq struct {
	DeviceName *string `json:"device_name,omitempty"` // 需要同步日历的设备名，在日历中展示用来管理密码, 示例值："iPhone", 最大长度：`100` 字符
}

type generateCaldavConfResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *GenerateCaldavConfResp `json:"data,omitempty"`
}

type GenerateCaldavConfResp struct {
	Password      string `json:"password,omitempty"`       // caldav密码
	UserName      string `json:"user_name,omitempty"`      // caldav用户名
	ServerAddress string `json:"server_address,omitempty"` // 服务器地址
	DeviceName    string `json:"device_name,omitempty"`    // 设备名
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetChatAnnouncement 获取会话中的群公告信息，公告信息格式与[云文档](https://open.feishu.cn/document/ukTMukTMukTM/uAzM5YjLwMTO24CMzkjN)格式相同。
//
// 注意事项：
// - 应用需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-announcement/get
func (r *ChatService) GetChatAnnouncement(ctx context.Context, request *GetChatAnnouncementReq, options ...MethodOptionFunc) (*GetChatAnnouncementResp, *Response, error) {
	if r.cli.mock.mockChatGetChatAnnouncement != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Chat#GetChatAnnouncement mock enable")
		return r.cli.mock.mockChatGetChatAnnouncement(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Chat",
		API:                   "GetChatAnnouncement",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/chats/:chat_id/announcement",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getChatAnnouncementResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockChatGetChatAnnouncement(f func(ctx context.Context, request *GetChatAnnouncementReq, options ...MethodOptionFunc) (*GetChatAnnouncementResp, *Response, error)) {
	r.mockChatGetChatAnnouncement = f
}

func (r *Mock) UnMockChatGetChatAnnouncement() {
	r.mockChatGetChatAnnouncement = nil
}

type GetChatAnnouncementReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	ChatID     string  `path:"chat_id" json:"-"`       // 待获取公告的群 ID，详情参见[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description), 示例值："oc_5ad11d72b830411d72b836c20"
}

type getChatAnnouncementResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *GetChatAnnouncementResp `json:"data,omitempty"`
}

type GetChatAnnouncementResp struct {
	Content        string `json:"content,omitempty"`          // 云文档序列化信息
	Revision       string `json:"revision,omitempty"`         // 文档当前版本号 纯数字
	CreateTime     string `json:"create_time,omitempty"`      // 文档生成的时间戳（秒）
	UpdateTime     string `json:"update_time,omitempty"`      // 文档更新的时间戳（秒）
	OwnerIDType    IDType `json:"owner_id_type,omitempty"`    // 文档所有者的 ID 类型, 如果所有者是用户，则与查询参数中的user_id_type 相同；取值为`open_id` `user_id` `union_id` 其中之一，不同 ID 的说明参见 [用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 如果所有者是机器人，为机器人应用的 `app_id`，详情参见  [获取应用身份访问凭证](https://open.feishu.cn/document/ukTMukTMukTM/ukDNz4SO0MjL5QzM/g), 可选值有: `user_id`：以 user_id 来识别用户, `union_id`：以 union_id 来识别用户, `open_id`：以 open_id 来识别用户, `app_id`：以 app_id 来识别机器人应用
	OwnerID        string `json:"owner_id,omitempty"`         // 文档所有者 ID，ID 值与owner_id_type 中的ID类型对应
	ModifierIDType IDType `json:"modifier_id_type,omitempty"` // 文档最新修改者 id 类型, - 如果修改者是用户，则与查询参数中的user_id_type 相同；取值为`open_id` `user_id` `union_id` 其中之一，不同 ID 的说明参见 [用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 如果修改者是机器人，为机器人应用的 `app_id`，详情参见  [获取应用身份访问凭证](https://open.feishu.cn/document/ukTMukTMukTM/ukDNz4SO0MjL5QzM/g), 可选值有: `user_id`：以 user_id 来识别用户, `union_id`：以 union_id 来识别用户, `open_id`：以 open_id 来识别用户, `app_id`：以 app_id 来识别应用
	ModifierID     string `json:"modifier_id,omitempty"`      // 文档最新修改者 ID，ID 值与modifier_id_type 中的ID类型对应
}
