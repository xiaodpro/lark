// Code generated by lark_sdk_gen. DO NOT EDIT.

package lark

import (
	"context"
)

// GetApplicationAppList
//
// 该接口用于查询企业安装的应用列表，只能被企业自建应用调用。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uYDN3UjL2QzN14iN0cTN
func (r *ApplicationService) GetApplicationAppList(ctx context.Context, request *GetApplicationAppListReq, options ...MethodOptionFunc) (*GetApplicationAppListResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationAppList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationAppList mock enable")
		return r.cli.mock.mockApplicationGetApplicationAppList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationAppList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v3/app/list",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationAppListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationAppList(f func(ctx context.Context, request *GetApplicationAppListReq, options ...MethodOptionFunc) (*GetApplicationAppListResp, *Response, error)) {
	r.mockApplicationGetApplicationAppList = f
}

func (r *Mock) UnMockApplicationGetApplicationAppList() {
	r.mockApplicationGetApplicationAppList = nil
}

type GetApplicationAppListReq struct {
	PageToken *string `query:"page_token" json:"-"` // 分页起始位置标示，不填表示从头开始
	PageSize  *int64  `query:"page_size" json:"-"`  // 单页需求最大个数（最大 100），0 自动最大个数
	Lang      *string `query:"lang" json:"-"`       // 优先展示的应用信息的语言版本（zh_cn：中文，en_us：英文，ja_jp：日文）
	Status    *int64  `query:"status" json:"-"`     // 要返回的应用的状态，0:停用；1:启用；-1:全部，默认为 -1
}

type getApplicationAppListResp struct {
	Code int64                      `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                     `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationAppListResp `json:"data,omitempty"` // 返回的业务信息，仅 code = 0 时有效
}

type GetApplicationAppListResp struct {
	PageToken  string                            `json:"page_token,omitempty"`  // 下一个请求页应当给的起始位置
	PageSize   int64                             `json:"page_size,omitempty"`   // 本次请求实际返回的页大小
	TotalCount int64                             `json:"total_count,omitempty"` // 可用的应用总数
	HasMore    int64                             `json:"has_more,omitempty"`    // 是否还有更多应用
	Lang       string                            `json:"lang,omitempty"`        // 当前选择的版本语言
	AppList    *GetApplicationAppListRespAppList `json:"app_list,omitempty"`    // 应用列表
}

type GetApplicationAppListRespAppList struct {
	AppID                string `json:"app_id,omitempty"`                 // 应用 ID
	PrimaryLanguage      string `json:"primary_language,omitempty"`       // 应用首选语言
	AppName              string `json:"app_name,omitempty"`               // 应用名称
	Description          string `json:"description,omitempty"`            // 应用描述
	AvatarURL            string `json:"avatar_url,omitempty"`             // 应用 icon
	AppSceneType         int64  `json:"app_scene_type,omitempty"`         // 应用类型，0：企业自建应用；1：应用商店应用
	Status               int64  `json:"status,omitempty"`                 // 启停状态，0：停用；1：启用
	MobileDefaultAbility int64  `json:"mobile_default_ability,omitempty"` // 移动端默认的应用功能，0：未开启；1：小程序；2：H5；8：机器人
	PcDefaultAbility     int64  `json:"pc_default_ability,omitempty"`     // PC客户端默认的应用功能，0：未开启；1：小程序；2：H5；8：机器人
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationAppVisibility
//
// 该接口用于查询应用在该企业内可以被使用的范围，只能被企业自建应用调用。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uIjM3UjLyIzN14iMycTN
func (r *ApplicationService) GetApplicationAppVisibility(ctx context.Context, request *GetApplicationAppVisibilityReq, options ...MethodOptionFunc) (*GetApplicationAppVisibilityResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationAppVisibility != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationAppVisibility mock enable")
		return r.cli.mock.mockApplicationGetApplicationAppVisibility(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationAppVisibility",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v2/app/visibility",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationAppVisibilityResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationAppVisibility(f func(ctx context.Context, request *GetApplicationAppVisibilityReq, options ...MethodOptionFunc) (*GetApplicationAppVisibilityResp, *Response, error)) {
	r.mockApplicationGetApplicationAppVisibility = f
}

func (r *Mock) UnMockApplicationGetApplicationAppVisibility() {
	r.mockApplicationGetApplicationAppVisibility = nil
}

type GetApplicationAppVisibilityReq struct {
	AppID         string  `query:"app_id" json:"-"`          // 目标应用的 ID
	UserPageToken *string `query:"user_page_token" json:"-"` // 分页拉取用户列表起始位置标示，不填表示从头开始
	UserPageSize  *int64  `query:"user_page_size" json:"-"`  // 本次拉取用户列表最大个数(最大值 1000 ，0 自动最大个数 )
}

type getApplicationAppVisibilityResp struct {
	Code int64                            `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                           `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationAppVisibilityResp `json:"data,omitempty"` // 返回的业务信息
}

type GetApplicationAppVisibilityResp struct {
	Departments    []*GetApplicationAppVisibilityRespDepartment `json:"departments,omitempty"`       // 可用部门列表
	Users          []*GetApplicationAppVisibilityRespUser       `json:"users,omitempty"`             // 可用用户列表（仅包含单独设置的用户，可用部门、用户组中的用户未展开）
	IsVisibleToAll int64                                        `json:"is_visible_to_all,omitempty"` // 是否全员可见，1：是，0：否
	HasMoreUsers   int64                                        `json:"has_more_users,omitempty"`    // 是否还有更多可见用户，1：是，0：否
	UserPageToken  string                                       `json:"user_page_token,omitempty"`   // 拉取下一页用户列表时使用的 user_page_token
}

type GetApplicationAppVisibilityRespDepartment struct {
	ID string `json:"id,omitempty"` // 自定义 department_id
}

type GetApplicationAppVisibilityRespUser struct {
	UserID string `json:"user_id,omitempty"` // 用户的 user_id，只返回给申请了 user_id 权限的企业自建应用
	OpenID string `json:"open_id,omitempty"` // 用户的 open_id
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateApplicationAppVisibility
//
// 该接口用于增加或者删除指定应用被哪些人可用，只能被企业自建应用调用。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/ucDN3UjL3QzN14yN0cTN
func (r *ApplicationService) UpdateApplicationAppVisibility(ctx context.Context, request *UpdateApplicationAppVisibilityReq, options ...MethodOptionFunc) (*UpdateApplicationAppVisibilityResp, *Response, error) {
	if r.cli.mock.mockApplicationUpdateApplicationAppVisibility != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#UpdateApplicationAppVisibility mock enable")
		return r.cli.mock.mockApplicationUpdateApplicationAppVisibility(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "UpdateApplicationAppVisibility",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v3/app/update_visibility",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(updateApplicationAppVisibilityResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationUpdateApplicationAppVisibility(f func(ctx context.Context, request *UpdateApplicationAppVisibilityReq, options ...MethodOptionFunc) (*UpdateApplicationAppVisibilityResp, *Response, error)) {
	r.mockApplicationUpdateApplicationAppVisibility = f
}

func (r *Mock) UnMockApplicationUpdateApplicationAppVisibility() {
	r.mockApplicationUpdateApplicationAppVisibility = nil
}

type UpdateApplicationAppVisibilityReq struct {
	AppID           string                                     `json:"app_id,omitempty"`             // 目标应用的 ID
	DelUsers        *UpdateApplicationAppVisibilityReqDelUsers `json:"del_users,omitempty"`          // 删除的用户列表，元素个数不超过 500，**先增加后删除**
	AddUsers        *UpdateApplicationAppVisibilityReqAddUsers `json:"add_users,omitempty"`          // 增加的用户列表，元素个数不超过500，**先增加后删除**
	IsVisiableToAll *int64                                     `json:"is_visiable_to_all,omitempty"` // 是否全员可见，0：否；1：是；不填：继续当前状态不改变
	AddDepartments  []string                                   `json:"add_departments,omitempty"`    // 添加的部门列表，元素个数不超过 500，**先增加后删除**
	DelDepartments  []string                                   `json:"del_departments,omitempty"`    // 删除的部门列表，元素个数不超过 500，**先增加后删除**
}

type UpdateApplicationAppVisibilityReqDelUsers struct {
	OpenID *string `json:"open_id,omitempty"` // 与 user_id 至少给其中之一，user_id 优先于 open_id
	UserID *string `json:"user_id,omitempty"`
}

type UpdateApplicationAppVisibilityReqAddUsers struct {
	OpenID *string `json:"open_id,omitempty"` // 与 user_id 至少给其中之一，user_id 优先于 open_id
	UserID *string `json:"user_id,omitempty"`
}

type updateApplicationAppVisibilityResp struct {
	Code int64                               `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                              `json:"msg,omitempty"`  // 返回码的描述
	Data *UpdateApplicationAppVisibilityResp `json:"data,omitempty"` // 返回的业务信息
}

type UpdateApplicationAppVisibilityResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// IsApplicationUserAdmin
//
// 该接口用于查询用户是否为应用管理员。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uITN1EjLyUTNx4iM1UTM
func (r *ApplicationService) IsApplicationUserAdmin(ctx context.Context, request *IsApplicationUserAdminReq, options ...MethodOptionFunc) (*IsApplicationUserAdminResp, *Response, error) {
	if r.cli.mock.mockApplicationIsApplicationUserAdmin != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#IsApplicationUserAdmin mock enable")
		return r.cli.mock.mockApplicationIsApplicationUserAdmin(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "IsApplicationUserAdmin",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v3/is_user_admin",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(isApplicationUserAdminResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationIsApplicationUserAdmin(f func(ctx context.Context, request *IsApplicationUserAdminReq, options ...MethodOptionFunc) (*IsApplicationUserAdminResp, *Response, error)) {
	r.mockApplicationIsApplicationUserAdmin = f
}

func (r *Mock) UnMockApplicationIsApplicationUserAdmin() {
	r.mockApplicationIsApplicationUserAdmin = nil
}

type IsApplicationUserAdminReq struct {
	OpenID     *string `query:"open_id" json:"-"`     // 用户 open_id，open_id 和 employee_id 两个参数必须包含其一，若同时传入取 open_id
	EmployeeID *string `query:"employee_id" json:"-"` // 用户 employee_id（同通讯录 v3 版本中的 user_id），open_id 和 employee_id 两个参数必须包含其一，若同时传入取 open_id
}

type isApplicationUserAdminResp struct {
	Code int64                       `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 返回码的描述
	Data *IsApplicationUserAdminResp `json:"data,omitempty"` // 返回的业务信息
}

type IsApplicationUserAdminResp struct {
	IsAppAdmin bool `json:"is_app_admin,omitempty"` // 用户是否为管理员，true 为是，false 为否
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationMessageDetail
//
// 查询应用在指定时间段内机器人消息详细信息。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uYTN0YjL2UDN24iN1QjN
func (r *ApplicationService) GetApplicationMessageDetail(ctx context.Context, request *GetApplicationMessageDetailReq, options ...MethodOptionFunc) (*GetApplicationMessageDetailResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationMessageDetail != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationMessageDetail mock enable")
		return r.cli.mock.mockApplicationGetApplicationMessageDetail(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationMessageDetail",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v1/app_message_detail",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationMessageDetailResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationMessageDetail(f func(ctx context.Context, request *GetApplicationMessageDetailReq, options ...MethodOptionFunc) (*GetApplicationMessageDetailResp, *Response, error)) {
	r.mockApplicationGetApplicationMessageDetail = f
}

func (r *Mock) UnMockApplicationGetApplicationMessageDetail() {
	r.mockApplicationGetApplicationMessageDetail = nil
}

type GetApplicationMessageDetailReq struct {
	AppID     string  `query:"app_id" json:"-"`     // 目标应用的 ID
	MessageID string  `query:"message_id" json:"-"` // open_message_id
	TimeStart int64   `query:"time_start" json:"-"` // 起始时间戳（秒），时间跨度最长支持180天
	TimeEnd   int64   `query:"time_end" json:"-"`   // 截止时间戳（秒），时间跨度最长支持180天
	PageToken *string `query:"page_token" json:"-"` // 分页标记，首次传空，非首次使用返回中的page_token
	PageSize  *int64  `query:"page_size" json:"-"`  // 分页大小，默认为512，取值区间[1,1000]
}

type getApplicationMessageDetailResp struct {
	Code int64                            `json:"code,omitempty"` // 返回码，非0表示失败
	Msg  string                           `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationMessageDetailResp `json:"data,omitempty"` // 返回的业务信息，仅code = 0时有效
}

type GetApplicationMessageDetailResp struct {
	MessageID   string                                    `json:"message_id,omitempty"`   // open_message_id
	ChatType    ChatType                                  `json:"chat_type,omitempty"`    // 聊天类型
	MessageType MsgType                                   `json:"message_type,omitempty"` // 消息类型
	Nsent       int64                                     `json:"nsent,omitempty"`        // 总发送数
	Target      *GetApplicationMessageDetailRespTarget    `json:"target,omitempty"`       // 发送目标用户列表，群聊为空
	Nread       int64                                     `json:"nread,omitempty"`        // 总阅读数
	UsersRead   *GetApplicationMessageDetailRespUsersRead `json:"users_read,omitempty"`   // 已读用户列表
	HasMore     bool                                      `json:"has_more,omitempty"`     // 是否还有更多分页，当 has_more 为 true 时，会同时返回新的 page_token
	PageToken   string                                    `json:"page_token,omitempty"`   // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

type GetApplicationMessageDetailRespTarget struct {
	OpenID string `json:"open_id,omitempty"` // open_id
}

type GetApplicationMessageDetailRespUsersRead struct {
	OpenID string `json:"open_id,omitempty"` // open_id
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationMessageOverview
//
// 查询应用在指定时间段内机器人消息概览信息。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uQTN0YjL0UDN24CN1QjN
func (r *ApplicationService) GetApplicationMessageOverview(ctx context.Context, request *GetApplicationMessageOverviewReq, options ...MethodOptionFunc) (*GetApplicationMessageOverviewResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationMessageOverview != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationMessageOverview mock enable")
		return r.cli.mock.mockApplicationGetApplicationMessageOverview(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationMessageOverview",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v1/app_message_overview",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationMessageOverviewResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationMessageOverview(f func(ctx context.Context, request *GetApplicationMessageOverviewReq, options ...MethodOptionFunc) (*GetApplicationMessageOverviewResp, *Response, error)) {
	r.mockApplicationGetApplicationMessageOverview = f
}

func (r *Mock) UnMockApplicationGetApplicationMessageOverview() {
	r.mockApplicationGetApplicationMessageOverview = nil
}

type GetApplicationMessageOverviewReq struct {
	AppID       string    `json:"app_id,omitempty"`       // 目标应用的 ID
	TimeStart   int64     `json:"time_start,omitempty"`   // 起始时间戳（秒），时间跨度最长支持180天
	TimeEnd     int64     `json:"time_end,omitempty"`     // 截止时间戳（秒），时间跨度最长支持180天
	ChatType    *ChatType `json:"chat_type,omitempty"`    // 聊天类型，大小写不敏感，p2p：私聊；group：群聊
	MessageType *MsgType  `json:"message_type,omitempty"` // 消息类型，大小写不敏感，text：文本消息；image：图片消息；card：卡片消息；post：富文本消息；share_chat：群名片
}

type getApplicationMessageOverviewResp struct {
	Code int64                              `json:"code,omitempty"` // 返回码，非0表示失败
	Msg  string                             `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationMessageOverviewResp `json:"data,omitempty"` // 返回的业务信息，仅code = 0时有效
}

type GetApplicationMessageOverviewResp struct {
	P2pSent       *GetApplicationMessageOverviewRespP2pSent       `json:"p2p_sent,omitempty"`       // 单聊发送
	P2pReceived   *GetApplicationMessageOverviewRespP2pReceived   `json:"p2p_received,omitempty"`   // 单聊接收
	P2pRead       *GetApplicationMessageOverviewRespP2pRead       `json:"p2p_read,omitempty"`       // 单聊已读
	GroupSent     *GetApplicationMessageOverviewRespGroupSent     `json:"group_sent,omitempty"`     // 群聊发送
	GroupReceived *GetApplicationMessageOverviewRespGroupReceived `json:"group_received,omitempty"` // 群聊接收
	GroupRead     *GetApplicationMessageOverviewRespGroupRead     `json:"group_read,omitempty"`     // 群聊已读
}

type GetApplicationMessageOverviewRespP2pSent struct {
	Pv *GetApplicationMessageOverviewRespP2pSentPv `json:"pv,omitempty"` // 消息接收用户数量
}

type GetApplicationMessageOverviewRespP2pSentPv struct {
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收用户数量
}

type GetApplicationMessageOverviewRespP2pReceived struct {
	Pv *GetApplicationMessageOverviewRespP2pReceivedPv `json:"pv,omitempty"` // 消息接收用户数量
}

type GetApplicationMessageOverviewRespP2pReceivedPv struct {
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收用户数量
}

type GetApplicationMessageOverviewRespP2pRead struct {
	Pv *GetApplicationMessageOverviewRespP2pReadPv `json:"pv,omitempty"` // 消息已读用户数量
}

type GetApplicationMessageOverviewRespP2pReadPv struct {
	Uv int64 `json:"uv,omitempty"` // 去重的消息已读用户数量
}

type GetApplicationMessageOverviewRespGroupSent struct {
	Pv *GetApplicationMessageOverviewRespGroupSentPv `json:"pv,omitempty"` // 消息接收群聊数量
}

type GetApplicationMessageOverviewRespGroupSentPv struct {
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收群聊数量
}

type GetApplicationMessageOverviewRespGroupReceived struct {
	Pv *GetApplicationMessageOverviewRespGroupReceivedPv `json:"pv,omitempty"` // 消息接收群聊数量
}

type GetApplicationMessageOverviewRespGroupReceivedPv struct {
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收群聊数量
}

type GetApplicationMessageOverviewRespGroupRead struct {
	Pv *GetApplicationMessageOverviewRespGroupReadPv `json:"pv,omitempty"` // 消息已读用户数量
}

type GetApplicationMessageOverviewRespGroupReadPv struct {
	Uv int64 `json:"uv,omitempty"` // 去重的消息已读用户数量
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationMessageTrend
//
// 查询应用在指定时间段内机器人消息趋势信息。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uUTN0YjL1UDN24SN1QjN
func (r *ApplicationService) GetApplicationMessageTrend(ctx context.Context, request *GetApplicationMessageTrendReq, options ...MethodOptionFunc) (*GetApplicationMessageTrendResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationMessageTrend != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationMessageTrend mock enable")
		return r.cli.mock.mockApplicationGetApplicationMessageTrend(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationMessageTrend",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v1/app_message_trend",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationMessageTrendResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationMessageTrend(f func(ctx context.Context, request *GetApplicationMessageTrendReq, options ...MethodOptionFunc) (*GetApplicationMessageTrendResp, *Response, error)) {
	r.mockApplicationGetApplicationMessageTrend = f
}

func (r *Mock) UnMockApplicationGetApplicationMessageTrend() {
	r.mockApplicationGetApplicationMessageTrend = nil
}

type GetApplicationMessageTrendReq struct {
	AppID        string    `json:"app_id,omitempty"`        // 目标应用的 ID
	TimeStart    int64     `json:"time_start,omitempty"`    // 起始时间戳（秒），时间跨度最长支持180天
	TimeEnd      int64     `json:"time_end,omitempty"`      // 截止时间戳（秒），时间跨度最长支持180天
	TimeInterval int64     `json:"time_interval,omitempty"` // 步长（秒），最小步长为60秒，需满足(${time_end} - ${time_start}) / ${time_interval} <= 2*24*60
	ChatType     *ChatType `json:"chat_type,omitempty"`     // 聊天类型，大小写不敏感，p2p：私聊；group：群聊
	MessageType  *MsgType  `json:"message_type,omitempty"`  // 消息类型，大小写不敏感，text：文本消息；image：图片消息；card：卡片消息；post：富文本消息；share_chat：群名片
}

type getApplicationMessageTrendResp struct {
	Code int64                           `json:"code,omitempty"` // 返回码，非0表示失败
	Msg  string                          `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationMessageTrendResp `json:"data,omitempty"` // 返回的业务信息，仅code = 0时有效
}

type GetApplicationMessageTrendResp struct {
	P2pSent       *GetApplicationMessageTrendRespP2pSent       `json:"p2p_sent,omitempty"`       // 单聊发送
	P2pReceived   *GetApplicationMessageTrendRespP2pReceived   `json:"p2p_received,omitempty"`   // 单聊接收
	P2pRead       *GetApplicationMessageTrendRespP2pRead       `json:"p2p_read,omitempty"`       // 单聊已读
	GroupSent     *GetApplicationMessageTrendRespGroupSent     `json:"group_sent,omitempty"`     // 群聊发送
	GroupReceived *GetApplicationMessageTrendRespGroupReceived `json:"group_received,omitempty"` // 群聊接收
	GroupRead     *GetApplicationMessageTrendRespGroupRead     `json:"group_read,omitempty"`     // 群聊已读
}

type GetApplicationMessageTrendRespP2pSent struct {
	Timestamp *GetApplicationMessageTrendRespP2pSentTimestamp `json:"timestamp,omitempty"` // 时间戳（秒）
}

type GetApplicationMessageTrendRespP2pSentTimestamp struct {
	Pv int64 `json:"pv,omitempty"` // 消息接收用户数量
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收用户数量
}

type GetApplicationMessageTrendRespP2pReceived struct {
	Timestamp *GetApplicationMessageTrendRespP2pReceivedTimestamp `json:"timestamp,omitempty"` // 时间戳（秒）
}

type GetApplicationMessageTrendRespP2pReceivedTimestamp struct {
	Pv int64 `json:"pv,omitempty"` // 消息接收用户数量
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收用户数量
}

type GetApplicationMessageTrendRespP2pRead struct {
	Timestamp *GetApplicationMessageTrendRespP2pReadTimestamp `json:"timestamp,omitempty"` // 时间戳（秒）
}

type GetApplicationMessageTrendRespP2pReadTimestamp struct {
	Pv int64 `json:"pv,omitempty"` // 消息已读用户数量
	Uv int64 `json:"uv,omitempty"` // 去重的消息已读用户数量
}

type GetApplicationMessageTrendRespGroupSent struct {
	Timestamp *GetApplicationMessageTrendRespGroupSentTimestamp `json:"timestamp,omitempty"` // 时间戳（秒）
}

type GetApplicationMessageTrendRespGroupSentTimestamp struct {
	Pv int64 `json:"pv,omitempty"` // 消息接收群聊数量
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收群聊数量
}

type GetApplicationMessageTrendRespGroupReceived struct {
	Timestamp *GetApplicationMessageTrendRespGroupReceivedTimestamp `json:"timestamp,omitempty"` // 时间戳（秒）
}

type GetApplicationMessageTrendRespGroupReceivedTimestamp struct {
	Pv int64 `json:"pv,omitempty"` // 消息接收群聊数量
	Uv int64 `json:"uv,omitempty"` // 去重的消息接收群聊数量
}

type GetApplicationMessageTrendRespGroupRead struct {
	Timestamp *GetApplicationMessageTrendRespGroupReadTimestamp `json:"timestamp,omitempty"` // 时间戳（秒）
}

type GetApplicationMessageTrendRespGroupReadTimestamp struct {
	Pv int64 `json:"pv,omitempty"` // 消息已读用户数量
	Uv int64 `json:"uv,omitempty"` // 去重的消息已读用户数量
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationOrder
//
// 该接口用于查询某个订单的具体信息
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uITNwUjLyUDM14iM1ATN
func (r *ApplicationService) GetApplicationOrder(ctx context.Context, request *GetApplicationOrderReq, options ...MethodOptionFunc) (*GetApplicationOrderResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationOrder != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationOrder mock enable")
		return r.cli.mock.mockApplicationGetApplicationOrder(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationOrder",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/pay/v1/order/get",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationOrderResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationOrder(f func(ctx context.Context, request *GetApplicationOrderReq, options ...MethodOptionFunc) (*GetApplicationOrderResp, *Response, error)) {
	r.mockApplicationGetApplicationOrder = f
}

func (r *Mock) UnMockApplicationGetApplicationOrder() {
	r.mockApplicationGetApplicationOrder = nil
}

type GetApplicationOrderReq struct {
	OrderID string `query:"order_id" json:"-"` // 订单ID
}

type getApplicationOrderResp struct {
	Code int64                    `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationOrderResp `json:"data,omitempty"` // 返回的业务信息
}

type GetApplicationOrderResp struct {
	Order *GetApplicationOrderRespOrder `json:"order,omitempty"` // 订单信息
}

type GetApplicationOrderRespOrder struct {
	OrderID       string `json:"order_id,omitempty"`        // 订单ID，唯一标识
	PricePlanID   string `json:"price_plan_id,omitempty"`   // 价格方案ID，唯一标识
	PricePlanType string `json:"price_plan_type,omitempty"` // 价格方案类型 "trial" -试用；"permanent"-一次性付费；"per_year"-企业年付费；"per_month"-企业月付费；"per_seat_per_year"-按人按年付费；"per_seat_per_month"-按人按月付费；"permanent_count"-按次付费；
	Seats         int64  `json:"seats,omitempty"`           // 实际购买人数 仅对price_plan_type为per_seat_per_year和per_seat_per_month 有效
	BuyCount      int64  `json:"buy_count,omitempty"`       // 购买数量 总是为1
	CreateTime    string `json:"create_time,omitempty"`     // 订单创建时间戳
	PayTime       string `json:"pay_time,omitempty"`        // 订单支付时间戳
	Status        string `json:"status,omitempty"`          // 订单当前状态，"normal" -正常；"refund"-已退款；
	BuyType       string `json:"buy_type,omitempty"`        // 购买类型，"buy" - 普通购买;"upgrade"-为升级购买(仅price_plan_type 为per_year，per_month，per_seat_per_year，per_seat_per_month时可升级购买);"renew" - 续费购买；
	SrcOrderID    string `json:"src_order_id,omitempty"`    // 源订单ID，当前订单为升级购买时，即buy_type为upgrade时，此字段记录源订单等ID
	DstOrderID    string `json:"dst_order_id,omitempty"`    // 升级后的新订单ID，当前订单如果做过升级购买，此字段记录升级购买后生成的新订单ID，当前订单仍然有效
	OrderPayPrice int64  `json:"order_pay_price,omitempty"` // 订单实际支付金额, 单位分
	TenantKey     string `json:"tenant_key,omitempty"`      // 租户唯一标识
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationOrderList
//
// 该接口用于分页查询应用租户下的已付费订单，每次购买对应一个唯一的订单，订单会记录购买的套餐的相关信息，业务方需要自行处理套餐的有效期和付费方案的升级。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uETNwUjLxUDM14SM1ATN
func (r *ApplicationService) GetApplicationOrderList(ctx context.Context, request *GetApplicationOrderListReq, options ...MethodOptionFunc) (*GetApplicationOrderListResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationOrderList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationOrderList mock enable")
		return r.cli.mock.mockApplicationGetApplicationOrderList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationOrderList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/pay/v1/order/list",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationOrderListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationOrderList(f func(ctx context.Context, request *GetApplicationOrderListReq, options ...MethodOptionFunc) (*GetApplicationOrderListResp, *Response, error)) {
	r.mockApplicationGetApplicationOrderList = f
}

func (r *Mock) UnMockApplicationGetApplicationOrderList() {
	r.mockApplicationGetApplicationOrderList = nil
}

type GetApplicationOrderListReq struct {
	Status    *string `query:"status" json:"-"`     // 获取用户购买套餐信息设置的过滤条件, normal为正常状态，refunded为已退款，该字段为空或者all表示所有，未支付的订单无法查到
	PageSize  int64   `query:"page_size" json:"-"`  // `每页显示的订单数量`
	PageToken *string `query:"page_token" json:"-"` // 翻页标识，可以从上次请求的响应中获取，不填或者为空时表示从开头获取
	TenantKey *string `query:"tenant_key" json:"-"` // 购买应用的租户唯一标识，为空表示获取应用下所有订单，有值表示获取应用下该租户购买的订单
}

type getApplicationOrderListResp struct {
	Code int64                        `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                       `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationOrderListResp `json:"data,omitempty"` // 返回的业务信息
}

type GetApplicationOrderListResp struct {
	Total     int64                                 `json:"total,omitempty"`      // 总订单数
	HasMore   bool                                  `json:"has_more,omitempty"`   // 是否还有数据，true还有数据，false没有数据
	PageToken string                                `json:"page_token,omitempty"` // 下一页数据的标识，可作为请求下一页数据的参数，当has_more为false时该字段为空
	OrderList *GetApplicationOrderListRespOrderList `json:"order_list,omitempty"` // 订单信息列表
}

type GetApplicationOrderListRespOrderList struct {
	OrderID       string `json:"order_id,omitempty"`        // 订单ID，唯一标识
	PricePlanID   string `json:"price_plan_id,omitempty"`   // 价格方案ID，唯一标识
	PricePlanType string `json:"price_plan_type,omitempty"` // 价格方案类型 "trial" -试用；"permanent"-一次性付费；"per_year"-企业年付费；"per_month"-企业月付费；"per_seat_per_year"-按人按年付费；"per_seat_per_month"-按人按月付费；"permanent_count"-按次付费；
	Seats         int64  `json:"seats,omitempty"`           // 实际购买人数 仅对price_plan_type为per_seat_per_year和per_seat_per_month 有效
	BuyCount      int64  `json:"buy_count,omitempty"`       // 购买数量 总是为1
	CreateTime    string `json:"create_time,omitempty"`     // 订单创建时间戳
	PayTime       string `json:"pay_time,omitempty"`        // 订单支付时间戳
	Status        string `json:"status,omitempty"`          // 订单当前状态，"normal" -正常；"refund"-已退款；
	BuyType       string `json:"buy_type,omitempty"`        // 购买类型，"buy" - 普通购买;"upgrade"-为升级购买(仅price_plan_type 为per_year，per_month，per_seat_per_year，per_seat_per_month时可升级购买);"renew" - 续费购买；
	SrcOrderID    string `json:"src_order_id,omitempty"`    // 源订单ID，当前订单为升级购买时，即buy_type为upgrade时，此字段记录源订单等ID
	DstOrderID    string `json:"dst_order_id,omitempty"`    // 升级后的新订单ID，当前订单如果做过升级购买，此字段记录升级购买后生成的新订单ID，当前订单仍然有效
	OrderPayPrice int64  `json:"order_pay_price,omitempty"` // 订单实际支付金额, 单位分
	TenantKey     string `json:"tenant_key,omitempty"`      // 租户唯一标识
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CheckUserIsInApplicationPaidScope
//
// 当付费套餐是按人数收费 或者 限制最大使用人数时，开放平台会引导企业管理员设置“付费功能开通范围”。  但是受开通范围限制，部分用户就无法使用对应的付费功能。  可以通过此接口，在付费功能点入口判断是否允许某个用户进入使用。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uATNwUjLwUDM14CM1ATN
func (r *ApplicationService) CheckUserIsInApplicationPaidScope(ctx context.Context, request *CheckUserIsInApplicationPaidScopeReq, options ...MethodOptionFunc) (*CheckUserIsInApplicationPaidScopeResp, *Response, error) {
	if r.cli.mock.mockApplicationCheckUserIsInApplicationPaidScope != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#CheckUserIsInApplicationPaidScope mock enable")
		return r.cli.mock.mockApplicationCheckUserIsInApplicationPaidScope(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "CheckUserIsInApplicationPaidScope",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/pay/v1/paid_scope/check_user",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(checkUserIsInApplicationPaidScopeResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationCheckUserIsInApplicationPaidScope(f func(ctx context.Context, request *CheckUserIsInApplicationPaidScopeReq, options ...MethodOptionFunc) (*CheckUserIsInApplicationPaidScopeResp, *Response, error)) {
	r.mockApplicationCheckUserIsInApplicationPaidScope = f
}

func (r *Mock) UnMockApplicationCheckUserIsInApplicationPaidScope() {
	r.mockApplicationCheckUserIsInApplicationPaidScope = nil
}

type CheckUserIsInApplicationPaidScopeReq struct {
	OpenID *string `query:"open_id" json:"-"` // 用户 open_id，open_id 和 user_id 两个参数必须包含其一，若同时传入取 open_id
	UserID *string `query:"user_id" json:"-"` // 用户 user_id，user_id 和 open_id 两个参数必须包含其一，若同时传入取 open_id
}

type checkUserIsInApplicationPaidScopeResp struct {
	Code int64                                  `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                                 `json:"msg,omitempty"`  // 返回码的描述
	Data *CheckUserIsInApplicationPaidScopeResp `json:"data,omitempty"` // 返回的业务信息
}

type CheckUserIsInApplicationPaidScopeResp struct {
	Status          string `json:"status,omitempty"`            // 用户是否在开通范围中，"valid" -该用户在开通范围中，"not_in_scope"-该用户不在开通范围中，"no_active_license"-企业未购买任何价格方案或价格方案已过期，"exceeds_maximum_limit"-企业当前配置的付费功能开通范围人数超出限制，需提醒管理员调整
	PricePlanID     string `json:"price_plan_id,omitempty"`     // 租户当前使用的「价格方案ID」，对应开发者后台中「价格方案配置」中的「价格方案」
	IsTrial         bool   `json:"is_trial,omitempty"`          // 是否为试用版本，true-是试用版本；false-非试用版本
	ServiceStopTime string `json:"service_stop_time,omitempty"` // 租户当前有生效价格方案时表示价格方案的到期时间，为时间unix时间戳
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationUsageDetail
//
// 查询应用在指定时间段内企业员工的使用详细信息。
// :::warning
// 此接口目前仅支持小程序的使用情况查询，不支持网页应用和机器人应用的使用情况查询;仅支持查询自建应用，不支持查询商店应用
// :::
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uMTN0YjLzUDN24yM1QjN
func (r *ApplicationService) GetApplicationUsageDetail(ctx context.Context, request *GetApplicationUsageDetailReq, options ...MethodOptionFunc) (*GetApplicationUsageDetailResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationUsageDetail != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationUsageDetail mock enable")
		return r.cli.mock.mockApplicationGetApplicationUsageDetail(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationUsageDetail",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v1/app_usage_detail",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationUsageDetailResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationUsageDetail(f func(ctx context.Context, request *GetApplicationUsageDetailReq, options ...MethodOptionFunc) (*GetApplicationUsageDetailResp, *Response, error)) {
	r.mockApplicationGetApplicationUsageDetail = f
}

func (r *Mock) UnMockApplicationGetApplicationUsageDetail() {
	r.mockApplicationGetApplicationUsageDetail = nil
}

type GetApplicationUsageDetailReq struct {
	AppID     string                                `json:"app_id,omitempty"`     // 目标应用的 ID，支持自建应用
	Ability   string                                `json:"ability,omitempty"`    // 应用能力，mp：小程序
	TimeStart int64                                 `json:"time_start,omitempty"` // 起始时间戳（秒），时间跨度最长支持180天
	TimeEnd   int64                                 `json:"time_end,omitempty"`   // 截止时间戳（秒），时间跨度最长支持180天
	Filters   []*GetApplicationUsageDetailReqFilter `json:"filters,omitempty"`    // 过滤条件
	OrderBy   *string                               `json:"order_by,omitempty"`   // 排序字段，大小写不敏感，支持open_id、timestamp，默认为open_id
	Order     *string                               `json:"order,omitempty"`      // 排序方式，大小写不敏感，desc：降序；asc：升序，默认值
	PageToken *string                               `json:"page_token,omitempty"` // 分页标记，首次传空，非首次使用返回中的page_token
	PageSize  *int64                                `json:"page_size,omitempty"`  // 分页大小，默认为512，取值区间[1,1000]
}

type GetApplicationUsageDetailReqFilter struct {
	Key   string `json:"key,omitempty"`   // 过滤字段，支持`department_id`
	Op    string `json:"op,omitempty"`    // 过滤操作，支持`in`、`=`
	Value string `json:"value,omitempty"` // 过滤字段值，多个使用英文逗号分隔
}

type getApplicationUsageDetailResp struct {
	Code int64                          `json:"code,omitempty"` // 返回码，非0表示失败
	Msg  string                         `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationUsageDetailResp `json:"data,omitempty"` // 返回的业务信息，仅code = 0时有效
}

type GetApplicationUsageDetailResp struct {
	HasMore   bool                                 `json:"has_more,omitempty"`   // 是否还有更多分页，当 has_more 为 true 时，会同时返回新的 page_token
	PageToken string                               `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
	Users     []*GetApplicationUsageDetailRespUser `json:"users,omitempty"`      // 用户列表
}

type GetApplicationUsageDetailRespUser struct {
	OpenID string `json:"open_id,omitempty"` // open_id
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationUsageOverview
//
// 查询应用在指定时间段内企业员工的使用概览信息。
// :::warning
// 此接口目前仅支持小程序的使用情况查询，不支持网页应用和机器人应用的使用情况查询；
// 仅支持查询自建应用，不支持查询商店应用
// :::
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uETN0YjLxUDN24SM1QjN
func (r *ApplicationService) GetApplicationUsageOverview(ctx context.Context, request *GetApplicationUsageOverviewReq, options ...MethodOptionFunc) (*GetApplicationUsageOverviewResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationUsageOverview != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationUsageOverview mock enable")
		return r.cli.mock.mockApplicationGetApplicationUsageOverview(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationUsageOverview",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v1/app_usage_overview",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationUsageOverviewResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationUsageOverview(f func(ctx context.Context, request *GetApplicationUsageOverviewReq, options ...MethodOptionFunc) (*GetApplicationUsageOverviewResp, *Response, error)) {
	r.mockApplicationGetApplicationUsageOverview = f
}

func (r *Mock) UnMockApplicationGetApplicationUsageOverview() {
	r.mockApplicationGetApplicationUsageOverview = nil
}

type GetApplicationUsageOverviewReq struct {
	AppID     string                                  `json:"app_id,omitempty"`     // 目标应用的 ID，支持自建应用
	Ability   string                                  `json:"ability,omitempty"`    // 应用能力，mp：小程序
	TimeStart int64                                   `json:"time_start,omitempty"` // 起始时间戳（秒），时间跨度最长支持180天
	TimeEnd   int64                                   `json:"time_end,omitempty"`   // 截止时间戳（秒），时间跨度最长支持180天
	Filters   []*GetApplicationUsageOverviewReqFilter `json:"filters,omitempty"`    // 过滤条件
}

type GetApplicationUsageOverviewReqFilter struct {
	Key   string `json:"key,omitempty"`   // 过滤字段，支持`department_id`
	Op    string `json:"op,omitempty"`    // 过滤操作，支持`in`、`=`
	Value string `json:"value,omitempty"` // 过滤字段值，多个使用英文逗号分隔
}

type getApplicationUsageOverviewResp struct {
	Code int64                            `json:"code,omitempty"` // 返回码，非0表示失败
	Msg  string                           `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationUsageOverviewResp `json:"data,omitempty"` // 返回的业务信息，仅code = 0时有效
}

type GetApplicationUsageOverviewResp struct {
	Item map[string]*GetApplicationUsageOverviewRespItem `json:"item,omitempty"` // 返回项
}

type GetApplicationUsageOverviewRespItem struct {
	Pv int64 `json:"pv,omitempty"` // 应用使用pv
	Uv int64 `json:"uv,omitempty"` // 应用使用uv
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationUsageTrend
//
// 查询应用在指定时间段内企业员工的使用趋势信息。
// :::warning
// 此接口目前仅支持小程序的使用情况查询，不支持网页应用和机器人应用的使用情况查询;仅支持查询自建应用，不支持查询商店应用
// :::
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uITN0YjLyUDN24iM1QjN
func (r *ApplicationService) GetApplicationUsageTrend(ctx context.Context, request *GetApplicationUsageTrendReq, options ...MethodOptionFunc) (*GetApplicationUsageTrendResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationUsageTrend != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationUsageTrend mock enable")
		return r.cli.mock.mockApplicationGetApplicationUsageTrend(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationUsageTrend",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v1/app_usage_trend",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationUsageTrendResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationUsageTrend(f func(ctx context.Context, request *GetApplicationUsageTrendReq, options ...MethodOptionFunc) (*GetApplicationUsageTrendResp, *Response, error)) {
	r.mockApplicationGetApplicationUsageTrend = f
}

func (r *Mock) UnMockApplicationGetApplicationUsageTrend() {
	r.mockApplicationGetApplicationUsageTrend = nil
}

type GetApplicationUsageTrendReq struct {
	AppID        string                               `json:"app_id,omitempty"`        // 目标应用的 ID，支持自建应用
	Ability      string                               `json:"ability,omitempty"`       // 应用能力，mp：小程序
	TimeStart    int64                                `json:"time_start,omitempty"`    // 起始时间戳（秒），时间跨度最长支持180天
	TimeEnd      int64                                `json:"time_end,omitempty"`      // 截止时间戳（秒），时间跨度最长支持180天
	TimeInterval int64                                `json:"time_interval,omitempty"` // 步长（秒），最小步长为60秒，需满足(${time_end} - ${time_start}) / ${time_interval} <= 2*24*60
	Filters      []*GetApplicationUsageTrendReqFilter `json:"filters,omitempty"`       // 过滤条件
}

type GetApplicationUsageTrendReqFilter struct {
	Key   string `json:"key,omitempty"`   // 过滤字段，支持`department_id`
	Op    string `json:"op,omitempty"`    // 过滤操作，支持`in`、`=`
	Value string `json:"value,omitempty"` // 过滤字段值，多个使用英文逗号分隔
}

type getApplicationUsageTrendResp struct {
	Code int64                         `json:"code,omitempty"` // 返回码，非0表示失败
	Msg  string                        `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationUsageTrendResp `json:"data,omitempty"` // 返回的业务信息，仅code = 0时有效
}

type GetApplicationUsageTrendResp struct {
	Item map[string]*GetApplicationUsageTrendRespItem `json:"item,omitempty"` // 返回项
}

type GetApplicationUsageTrendRespItem struct {
	Trends []*GetApplicationUsageTrendRespItemTrend `json:"trends,omitempty"` // 趋势数据
}

type GetApplicationUsageTrendRespItemTrend struct {
	Timestamp int64 `json:"timestamp,omitempty"` // 时间戳
	Pv        int64 `json:"pv,omitempty"`        // 应用使用pv
	Uv        int64 `json:"uv,omitempty"`        // 应用使用uv
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationUserAdminScope
//
// 该接口用于获取应用管理员的管理范围，即该应用管理员能够管理哪些部门。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uMzN3QjLzczN04yM3cDN
func (r *ApplicationService) GetApplicationUserAdminScope(ctx context.Context, request *GetApplicationUserAdminScopeReq, options ...MethodOptionFunc) (*GetApplicationUserAdminScopeResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationUserAdminScope != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationUserAdminScope mock enable")
		return r.cli.mock.mockApplicationGetApplicationUserAdminScope(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationUserAdminScope",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/contact/v1/user/admin_scope/get",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationUserAdminScopeResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationUserAdminScope(f func(ctx context.Context, request *GetApplicationUserAdminScopeReq, options ...MethodOptionFunc) (*GetApplicationUserAdminScopeResp, *Response, error)) {
	r.mockApplicationGetApplicationUserAdminScope = f
}

func (r *Mock) UnMockApplicationGetApplicationUserAdminScope() {
	r.mockApplicationGetApplicationUserAdminScope = nil
}

type GetApplicationUserAdminScopeReq struct {
	EmployeeID string `query:"employee_id" json:"-"` // 支持通过 open_id 或者 employee_id 查询，不支持混合两种 ID 进行查询，其中 employee_id 同通讯录 v3 版本中的 user_id
	OpenID     string `query:"open_id" json:"-"`     // 支持通过 open_id 或者 employee_id 查询，不支持混合两种 ID 进行查询，其中 employee_id 同通讯录 v3 版本中的 user_id
}

type getApplicationUserAdminScopeResp struct {
	Code int64                             `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                            `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationUserAdminScopeResp `json:"data,omitempty"` // 返回业务数据
}

type GetApplicationUserAdminScopeResp struct {
	IsAll          bool     `json:"is_all,omitempty"`          // 是否管理所有部门
	DepartmentList []string `json:"department_list,omitempty"` // 管理的部门列表，当 is_all 为 true 时，不返回该字段
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApplicationUserVisibleApp
//
// 该接口用于查询用户可用的应用列表，只能被企业自建应用调用。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uMjM3UjLzIzN14yMycTN
func (r *ApplicationService) GetApplicationUserVisibleApp(ctx context.Context, request *GetApplicationUserVisibleAppReq, options ...MethodOptionFunc) (*GetApplicationUserVisibleAppResp, *Response, error) {
	if r.cli.mock.mockApplicationGetApplicationUserVisibleApp != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Application#GetApplicationUserVisibleApp mock enable")
		return r.cli.mock.mockApplicationGetApplicationUserVisibleApp(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Application",
		API:                   "GetApplicationUserVisibleApp",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/application/v1/user/visible_apps",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApplicationUserVisibleAppResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApplicationGetApplicationUserVisibleApp(f func(ctx context.Context, request *GetApplicationUserVisibleAppReq, options ...MethodOptionFunc) (*GetApplicationUserVisibleAppResp, *Response, error)) {
	r.mockApplicationGetApplicationUserVisibleApp = f
}

func (r *Mock) UnMockApplicationGetApplicationUserVisibleApp() {
	r.mockApplicationGetApplicationUserVisibleApp = nil
}

type GetApplicationUserVisibleAppReq struct {
	PageToken *string `query:"page_token" json:"-"` // 分页起始位置标示，不填表示从头开始
	PageSize  *int64  `query:"page_size" json:"-"`  // 单页需求最大个数（最大 100），0 自动最大个数
	Lang      *string `query:"lang" json:"-"`       // 优先展示的应用信息的语言版本（zh_cn：中文，en_us：英文，ja_jp：日文）
	OpenID    *string `query:"open_id" json:"-"`    // 目标用户 open_id
	UserID    *string `query:"user_id" json:"-"`    // 目标用户 user_id，与 open_id 至少给其中之一，user_id 优先于 open_id
}

type getApplicationUserVisibleAppResp struct {
	Code int64                             `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                            `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApplicationUserVisibleAppResp `json:"data,omitempty"` // 返回的业务信息，仅 code = 0 时有效
}

type GetApplicationUserVisibleAppResp struct {
	PageToken  string                                   `json:"page_token,omitempty"`  // 下一个请求页应当给的起始位置
	PageSize   int64                                    `json:"page_size,omitempty"`   // 本次请求实际返回的页大小
	TotalCount int64                                    `json:"total_count,omitempty"` // 可用的应用总数
	HasMore    int64                                    `json:"has_more,omitempty"`    // 是否还有更多应用
	Lang       string                                   `json:"lang,omitempty"`        // 当前选择的版本语言
	AppList    *GetApplicationUserVisibleAppRespAppList `json:"app_list,omitempty"`    // 应用列表
}

type GetApplicationUserVisibleAppRespAppList struct {
	AppID                string `json:"app_id,omitempty"`                 // 应用 ID
	PrimaryLanguage      string `json:"primary_language,omitempty"`       // 应用首选语言
	AppName              string `json:"app_name,omitempty"`               // 应用名称
	Description          string `json:"description,omitempty"`            // 应用描述
	AvatarURL            string `json:"avatar_url,omitempty"`             // 应用 icon
	AppSceneType         int64  `json:"app_scene_type,omitempty"`         // 应用类型，0：企业自建应用；1：应用商店应用
	Status               int64  `json:"status,omitempty"`                 // 启停状态，0：停用；1：启用
	MobileDefaultAbility int64  `json:"mobile_default_ability,omitempty"` // 移动端默认的应用功能，0：未开启；1：小程序；2：H5；8：机器人
	PcDefaultAbility     int64  `json:"pc_default_ability,omitempty"`     // PC客户端默认的应用功能，0：未开启；1：小程序；2：H5；8：机器人
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetApproval
//
// 根据 Approval Code 获取某个审批定义的详情，用于构造创建审批实例的请求。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uADNyUjLwQjM14CM0ITN
func (r *ApprovalService) GetApproval(ctx context.Context, request *GetApprovalReq, options ...MethodOptionFunc) (*GetApprovalResp, *Response, error) {
	if r.cli.mock.mockApprovalGetApproval != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Approval#GetApproval mock enable")
		return r.cli.mock.mockApprovalGetApproval(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Approval",
		API:                   "GetApproval",
		Method:                "POST",
		URL:                   r.cli.wwwBaseURL + "/approval/openapi/v2/approval/get",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getApprovalResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockApprovalGetApproval(f func(ctx context.Context, request *GetApprovalReq, options ...MethodOptionFunc) (*GetApprovalResp, *Response, error)) {
	r.mockApprovalGetApproval = f
}

func (r *Mock) UnMockApprovalGetApproval() {
	r.mockApprovalGetApproval = nil
}

type GetApprovalReq struct {
	ApprovalCode string  `json:"approval_code,omitempty"` // 审批定义 Code
	Locale       *string `json:"locale,omitempty"`        // zh-CN - 中文<br>en-US - 英文  <br>ja-JP - 日文
}

type getApprovalResp struct {
	Code int64            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string           `json:"msg,omitempty"`  // 返回码的描述
	Data *GetApprovalResp `json:"data,omitempty"` // 返回业务信息
}

type GetApprovalResp struct {
	ApprovalName string                   `json:"approval_name,omitempty"` // 审批名称
	Form         ApprovalWidgetList       `json:"form,omitempty"`          // json 数组，**控件信息**
	NodeList     []*GetApprovalRespNode   `json:"node_list,omitempty"`     // 节点信息
	Viewers      []*GetApprovalRespViewer `json:"viewers,omitempty"`       // 可见人列表
}

type GetApprovalRespNode struct {
	Name         string  `json:"name,omitempty"`           // 节点名称
	NeedApprover bool    `json:"need_approver,omitempty"`  // 是否发起人自选节点<br>true - 发起审批时需要提交审批人
	NodeID       string  `json:"node_id,omitempty"`        // 节点 ID
	CustomNodeID *string `json:"custom_node_id,omitempty"` // 节点自定义 ID，如果没有设置则不返回
	NodeType     string  `json:"node_type,omitempty"`      // 审批方式<br>AND -会签<br>OR - 或签<br>CC_NODE -抄送节点
}

type GetApprovalRespViewer struct {
	Type   string  `json:"type,omitempty"`    // 可见人类型，分别有：<br>TENANT：租户内可见<br>DEPARTMENT：指定部门<br> USER：指定用户<br>NONE：任何人都不可见
	OpenID *string `json:"open_id,omitempty"` // 在可见人类型为DEPARTMENT时，open_id为部门的open_id<br>在可见人类型为USER时，open_id为用户的open_id
	UserID *string `json:"user_id,omitempty"` // 在可见人类型为USER时，表示可见人用户id
}
